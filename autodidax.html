
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Autodidax: JAX core from scratch &#8212; JAX  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=5b4479735964841361fd" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=5b4479735964841361fd" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/style.css?v=7143c0a5" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=5b4479735964841361fd" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=5b4479735964841361fd"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=30646c52"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'autodidax';</script>
    <link rel="icon" href="_static/favicon.png"/>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Autodidax2, part 1: JAX from scratch, again" href="autodidax2_part1.html" />
    <link rel="prev" title="Investigating a regression" href="investigating_a_regression.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/jax_logo_250px.png" class="logo__image only-light" alt="JAX  documentation - Home"/>
    <script>document.write(`<img src="_static/jax_logo_250px.png" class="logo__image only-dark" alt="JAX  documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/thinking_in_jax.html">Quickstart: How to think in JAX</a></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="notebooks/Common_Gotchas_in_JAX.html">üî™ JAX - The Sharp Bits üî™</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="tutorials.html">Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="jit-compilation.html">Just-in-time compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="automatic-vectorization.html">Automatic vectorization</a></li>
<li class="toctree-l2"><a class="reference internal" href="automatic-differentiation.html">Automatic differentiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="random-numbers.html">Pseudorandom numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="stateful-computations.html">Stateful computations</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html">Control flow and logical operators with JIT</a></li>
<li class="toctree-l2"><a class="reference internal" href="pytrees.html">Pytrees</a></li>
<li class="toctree-l2"><a class="reference internal" href="working-with-pytrees.html">Working with pytrees</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Resources, guides, and references</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="key-concepts.html">Key concepts</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="advanced_guides.html">Resources and Advanced Guides</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="notebooks/autodiff_cookbook.html">The Autodiff Cookbook</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/Custom_derivative_rules_for_Python_code.html">Custom derivative rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/autodiff_remat.html">Control autodiff‚Äôs saved values with <code class="docutils literal notranslate"><span class="pre">jax.checkpoint</span></code> (aka <code class="docutils literal notranslate"><span class="pre">jax.remat</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced-autodiff.html">Advanced automatic differentiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="errors.html">Errors</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="debugging.html">Introduction to debugging</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="debugging/print_breakpoint.html">Compiled prints and breakpoints</a></li>
<li class="toctree-l3"><a class="reference internal" href="debugging/checkify_guide.html">The <code class="docutils literal notranslate"><span class="pre">checkify</span></code> transformation</a></li>
<li class="toctree-l3"><a class="reference internal" href="debugging/flags.html">JAX debugging flags</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="debugging/flags.html">JAX debugging flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="transfer_guard.html">Transfer guard</a></li>
<li class="toctree-l2"><a class="reference internal" href="persistent_compilation_cache.html">Persistent compilation cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpu_performance_tips.html">GPU performance tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="profiling.html">Profiling computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_memory_profiling.html">Profiling device memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/Distributed_arrays_and_automatic_parallelization.html">Distributed arrays and automatic parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/explicit-sharding.html">Explicit sharding (a.k.a. ‚Äúsharding in types‚Äù)</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/shard_map.html">Manual parallelism with <code class="docutils literal notranslate"><span class="pre">shard_map</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/layout.html">Device-local array layout control</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/host-offloading.html">JAX Memories and Host Offloading</a></li>

<li class="toctree-l2"><a class="reference internal" href="multi_process.html">Introduction to multi-controller JAX (aka multi-process/multi-host JAX)</a></li>
<li class="toctree-l2"><a class="reference internal" href="distributed_data_loading.html">Distributed data loading</a></li>
<li class="toctree-l2"><a class="reference internal" href="external-callbacks.html">External callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="gradient-checkpointing.html">Gradient checkpointing with <code class="docutils literal notranslate"><span class="pre">jax.checkpoint</span></code> (<code class="docutils literal notranslate"><span class="pre">jax.remat</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="aot.html">Ahead-of-time lowering and compilation</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="export/index.html">Exporting and serialization</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="export/export.html">Exporting and serializing staged-out computations</a></li>
<li class="toctree-l3"><a class="reference internal" href="export/shape_poly.html">Shape polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="export/jax2tf.html">Interoperation with TensorFlow</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="type_promotion.html">Type promotion semantics</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="pallas/index.html">Pallas: a JAX kernel language</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="pallas/quickstart.html">Pallas Quickstart</a></li>
<li class="toctree-l3"><a class="reference internal" href="pallas/pipelining.html">Software Pipelining</a></li>
<li class="toctree-l3"><a class="reference internal" href="pallas/grid_blockspec.html">Grids and BlockSpecs</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="pallas/tpu/index.html">Pallas TPU</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="pallas/tpu/details.html">Writing TPU kernels with Pallas</a></li>
<li class="toctree-l4"><a class="reference internal" href="pallas/tpu/pipelining.html">TPU Pipelining</a></li>
<li class="toctree-l4"><a class="reference internal" href="pallas/tpu/matmul.html">Matrix Multiplication</a></li>
<li class="toctree-l4"><a class="reference internal" href="pallas/tpu/sparse.html">Scalar Prefetch and Block-Sparse Computation</a></li>
<li class="toctree-l4"><a class="reference internal" href="pallas/tpu/distributed.html">Distributed Computing in Pallas for TPUs</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="pallas/gpu/index.html">Pallas:Mosaic GPU</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="pallas/gpu/reference.html">Writing Mosaic GPU kernels with Pallas</a></li>
<li class="toctree-l4"><a class="reference internal" href="pallas/gpu/pipelining.html">Mosaic GPU Pipelining</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="pallas/design/index.html">Pallas Design Notes</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="pallas/design/design.html">Pallas Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="pallas/design/async_note.html">Pallas Async Operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pallas/CHANGELOG.html">Pallas Changelog</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/neural_network_with_tfds_data.html">Training a simple neural network, with tensorflow/datasets data loading</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/Neural_Network_and_Data_Loading.html">Training a simple neural network, with PyTorch data loading</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/vmapped_log_probs.html">Autobatching for Bayesian inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks/convolutions.html">Generalized convolutions in JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="xla_flags.html">XLA compiler flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="sharded-computation.html">Introduction to parallel programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax-primitives.html">JAX Internals: primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="jaxpr.html">JAX internals: The jaxpr language</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="contributor_guide.html">Developer notes</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="contributing.html">Contributing to JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer.html">Building from source</a></li>
<li class="toctree-l2"><a class="reference internal" href="investigating_a_regression.html">Investigating a regression</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Autodidax: JAX core from scratch</a></li>
<li class="toctree-l2"><a class="reference internal" href="autodidax2_part1.html">Autodidax2, part 1: JAX from scratch, again</a></li>

<li class="toctree-l2 has-children"><a class="reference internal" href="jep/index.html">JAX Enhancement Proposals (JEPs)</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="jep/263-prng.html">263: JAX PRNG Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/2026-custom-derivatives.html">2026: Custom JVP/VJP rules for JAX-transformable functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/4008-custom-vjp-update.html">4008: Custom VJP and `nondiff_argnums` update</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/4410-omnistaging.html">4410: Omnistaging</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/9263-typed-keys.html">9263: Typed keys &amp; pluggable RNGs</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/9407-type-promotion.html">9407: Design of Type Promotion Semantics for JAX</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/9419-jax-versioning.html">9419: Jax and Jaxlib versioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/10657-sequencing-effects.html">10657: Sequencing side-effects in JAX</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/11830-new-remat-checkpoint.html">11830: `jax.remat` / `jax.checkpoint` new implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/12049-type-annotations.html">12049: Type Annotation Roadmap for JAX</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/14273-shard-map.html">14273: `shard_map` (`shmap`) for simple per-device code</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/15856-jex.html">15856: `jax.extend`, an extensions module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/17111-shmap-transpose.html">17111: Efficient transposition of `shard_map` (and other maps)</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/18137-numpy-scipy-scope.html">18137: Scope of JAX NumPy &amp; SciPy Wrappers</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/25516-effver.html">25516: Effort-based versioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="jep/28661-jax-array-protocol.html">28661: Supporting the `__jax_array__` protocol</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="extensions.html">Extension guides</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="notebooks/Writing_custom_interpreters_in_Jax.html">Writing custom Jaxpr interpreters in JAX</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="jax.extend.html"><code class="docutils literal notranslate"><span class="pre">jax.extend</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="jax.extend.core.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.core</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.extend.linear_util.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.linear_util</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.extend.mlir.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.mlir</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.extend.random.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.random</span></code> module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="building_on_jax.html">Building on JAX</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="notes.html">Notes</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-13"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="api_compatibility.html">API compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="deprecation.html">Python and NumPy version support policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="async_dispatch.html">Asynchronous dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpu_memory_allocation.html">GPU memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="rank_promotion_warning.html">Rank promotion warning</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_promotion.html">Type promotion semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="default_dtypes.html">Default dtypes and the X64 flag</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="jax.html">Public API: <code class="docutils literal notranslate"><span class="pre">jax</span></code> package</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-14"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="jax.numpy.html"><code class="docutils literal notranslate"><span class="pre">jax.numpy</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-15"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.fft.html">jax.numpy.fft.fft</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.fft2.html">jax.numpy.fft.fft2</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.fftfreq.html">jax.numpy.fft.fftfreq</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.fftn.html">jax.numpy.fft.fftn</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.fftshift.html">jax.numpy.fft.fftshift</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.hfft.html">jax.numpy.fft.hfft</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.ifft.html">jax.numpy.fft.ifft</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.ifft2.html">jax.numpy.fft.ifft2</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.ifftn.html">jax.numpy.fft.ifftn</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.ifftshift.html">jax.numpy.fft.ifftshift</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.ihfft.html">jax.numpy.fft.ihfft</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.irfft.html">jax.numpy.fft.irfft</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.irfft2.html">jax.numpy.fft.irfft2</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.irfftn.html">jax.numpy.fft.irfftn</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.rfft.html">jax.numpy.fft.rfft</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.rfft2.html">jax.numpy.fft.rfft2</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.rfftfreq.html">jax.numpy.fft.rfftfreq</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.numpy.fft.rfftn.html">jax.numpy.fft.rfftn</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="jax.scipy.html"><code class="docutils literal notranslate"><span class="pre">jax.scipy</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-16"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.scipy.stats.bernoulli.logpmf.html">jax.scipy.stats.bernoulli.logpmf</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.scipy.stats.bernoulli.pmf.html">jax.scipy.stats.bernoulli.pmf</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.scipy.stats.bernoulli.cdf.html">jax.scipy.stats.bernoulli.cdf</a></li>
<li class="toctree-l3"><a class="reference internal" href="_autosummary/jax.scipy.stats.bernoulli.ppf.html">jax.scipy.stats.bernoulli.ppf</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="jax.lax.html"><code class="docutils literal notranslate"><span class="pre">jax.lax</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.random.html"><code class="docutils literal notranslate"><span class="pre">jax.random</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.sharding.html"><code class="docutils literal notranslate"><span class="pre">jax.sharding</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.debug.html"><code class="docutils literal notranslate"><span class="pre">jax.debug</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.dlpack.html"><code class="docutils literal notranslate"><span class="pre">jax.dlpack</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.distributed.html"><code class="docutils literal notranslate"><span class="pre">jax.distributed</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.dtypes.html"><code class="docutils literal notranslate"><span class="pre">jax.dtypes</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.ffi.html"><code class="docutils literal notranslate"><span class="pre">jax.ffi</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.flatten_util.html"><code class="docutils literal notranslate"><span class="pre">jax.flatten_util</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.image.html"><code class="docutils literal notranslate"><span class="pre">jax.image</span></code> module</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="jax.nn.html"><code class="docutils literal notranslate"><span class="pre">jax.nn</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-17"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="jax.nn.initializers.html"><code class="docutils literal notranslate"><span class="pre">jax.nn.initializers</span></code> module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="jax.ops.html"><code class="docutils literal notranslate"><span class="pre">jax.ops</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.profiler.html"><code class="docutils literal notranslate"><span class="pre">jax.profiler</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.stages.html"><code class="docutils literal notranslate"><span class="pre">jax.stages</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.test_util.html"><code class="docutils literal notranslate"><span class="pre">jax.test_util</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.tree.html"><code class="docutils literal notranslate"><span class="pre">jax.tree</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.tree_util.html"><code class="docutils literal notranslate"><span class="pre">jax.tree_util</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.typing.html"><code class="docutils literal notranslate"><span class="pre">jax.typing</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="jax.export.html"><code class="docutils literal notranslate"><span class="pre">jax.export</span></code> module</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="jax.extend.html"><code class="docutils literal notranslate"><span class="pre">jax.extend</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-18"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="jax.extend.core.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.core</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.extend.linear_util.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.linear_util</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.extend.mlir.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.mlir</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.extend.random.html"><code class="docutils literal notranslate"><span class="pre">jax.extend.random</span></code> module</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="jax.example_libraries.html"><code class="docutils literal notranslate"><span class="pre">jax.example_libraries</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-19"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="jax.example_libraries.optimizers.html"><code class="docutils literal notranslate"><span class="pre">jax.example_libraries.optimizers</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.example_libraries.stax.html"><code class="docutils literal notranslate"><span class="pre">jax.example_libraries.stax</span></code> module</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="jax.experimental.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-20"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.checkify.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.checkify</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.compilation_cache.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.compilation_cache</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.custom_dce.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.custom_dce</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.custom_partitioning.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.custom_partitioning</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.jet.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.jet</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.key_reuse.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.key_reuse</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.mesh_utils.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.mesh_utils</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.multihost_utils.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.multihost_utils</span></code> module</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="jax.experimental.pallas.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.pallas</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-21" name="toctree-checkbox-21" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-21"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="jax.experimental.pallas.mosaic_gpu.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.pallas.mosaic_gpu</span></code> module</a></li>
<li class="toctree-l4"><a class="reference internal" href="jax.experimental.pallas.triton.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.pallas.triton</span></code> module</a></li>
<li class="toctree-l4"><a class="reference internal" href="jax.experimental.pallas.tpu.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.pallas.tpu</span></code> module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.pjit.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.pjit</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.serialize_executable.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.serialize_executable</span></code> module</a></li>
<li class="toctree-l3"><a class="reference internal" href="jax.experimental.shard_map.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.shard_map</span></code> module</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="jax.experimental.sparse.html"><code class="docutils literal notranslate"><span class="pre">jax.experimental.sparse</span></code> module</a><input class="toctree-checkbox" id="toctree-checkbox-22" name="toctree-checkbox-22" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-22"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.BCOO.html">jax.experimental.sparse.BCOO</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_broadcast_in_dim.html">jax.experimental.sparse.bcoo_broadcast_in_dim</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_concatenate.html">jax.experimental.sparse.bcoo_concatenate</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_dot_general.html">jax.experimental.sparse.bcoo_dot_general</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_dot_general_sampled.html">jax.experimental.sparse.bcoo_dot_general_sampled</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_dynamic_slice.html">jax.experimental.sparse.bcoo_dynamic_slice</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_extract.html">jax.experimental.sparse.bcoo_extract</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_fromdense.html">jax.experimental.sparse.bcoo_fromdense</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_gather.html">jax.experimental.sparse.bcoo_gather</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_multiply_dense.html">jax.experimental.sparse.bcoo_multiply_dense</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_multiply_sparse.html">jax.experimental.sparse.bcoo_multiply_sparse</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_update_layout.html">jax.experimental.sparse.bcoo_update_layout</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_reduce_sum.html">jax.experimental.sparse.bcoo_reduce_sum</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_reshape.html">jax.experimental.sparse.bcoo_reshape</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_slice.html">jax.experimental.sparse.bcoo_slice</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_sort_indices.html">jax.experimental.sparse.bcoo_sort_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_squeeze.html">jax.experimental.sparse.bcoo_squeeze</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_sum_duplicates.html">jax.experimental.sparse.bcoo_sum_duplicates</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_todense.html">jax.experimental.sparse.bcoo_todense</a></li>
<li class="toctree-l4"><a class="reference internal" href="_autosummary/jax.experimental.sparse.bcoo_transpose.html">jax.experimental.sparse.bcoo_transpose</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="jax.lib.html"><code class="docutils literal notranslate"><span class="pre">jax.lib</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.addressable_shards.html">jax.Array.addressable_shards</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.all.html">jax.Array.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.any.html">jax.Array.any</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.argmax.html">jax.Array.argmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.argmin.html">jax.Array.argmin</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.argpartition.html">jax.Array.argpartition</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.argsort.html">jax.Array.argsort</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.astype.html">jax.Array.astype</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.at.html">jax.Array.at</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.choose.html">jax.Array.choose</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.clip.html">jax.Array.clip</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.compress.html">jax.Array.compress</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.committed.html">jax.Array.committed</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.conj.html">jax.Array.conj</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.conjugate.html">jax.Array.conjugate</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.copy.html">jax.Array.copy</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.copy_to_host_async.html">jax.Array.copy_to_host_async</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.cumprod.html">jax.Array.cumprod</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.cumsum.html">jax.Array.cumsum</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.device.html">jax.Array.device</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.diagonal.html">jax.Array.diagonal</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.dot.html">jax.Array.dot</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.dtype.html">jax.Array.dtype</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.flat.html">jax.Array.flat</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.flatten.html">jax.Array.flatten</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.global_shards.html">jax.Array.global_shards</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.imag.html">jax.Array.imag</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.is_fully_addressable.html">jax.Array.is_fully_addressable</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.is_fully_replicated.html">jax.Array.is_fully_replicated</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.item.html">jax.Array.item</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.itemsize.html">jax.Array.itemsize</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.max.html">jax.Array.max</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.mean.html">jax.Array.mean</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.min.html">jax.Array.min</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.nbytes.html">jax.Array.nbytes</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.ndim.html">jax.Array.ndim</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.nonzero.html">jax.Array.nonzero</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.prod.html">jax.Array.prod</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.ptp.html">jax.Array.ptp</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.ravel.html">jax.Array.ravel</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.real.html">jax.Array.real</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.repeat.html">jax.Array.repeat</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.reshape.html">jax.Array.reshape</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.round.html">jax.Array.round</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.searchsorted.html">jax.Array.searchsorted</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.shape.html">jax.Array.shape</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.sharding.html">jax.Array.sharding</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.size.html">jax.Array.size</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.sort.html">jax.Array.sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.squeeze.html">jax.Array.squeeze</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.std.html">jax.Array.std</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.sum.html">jax.Array.sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.swapaxes.html">jax.Array.swapaxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.take.html">jax.Array.take</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.to_device.html">jax.Array.to_device</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.trace.html">jax.Array.trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.transpose.html">jax.Array.transpose</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.var.html">jax.Array.var</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.view.html">jax.Array.view</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.T.html">jax.Array.T</a></li>
<li class="toctree-l2"><a class="reference internal" href="_autosummary/jax.Array.mT.html">jax.Array.mT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="about.html">About the project</a></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently asked questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Change log</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary of terms</a></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="config_options.html">Configuration Options</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="contributor_guide.html" class="nav-link">Developer notes</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">Autodidax:...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/jax-ml/jax" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/autodidax.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Autodidax: JAX core from scratch</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-1-transformations-as-interpreters-standard-evaluation-jvp-and-vmap">Part 1: Transformations as interpreters: standard evaluation, <code class="docutils literal notranslate"><span class="pre">jvp</span></code>, and <code class="docutils literal notranslate"><span class="pre">vmap</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#jax-core-machinery">JAX core machinery</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#evaluation-interpreter">Evaluation interpreter</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forward-mode-autodiff-with-jvp">Forward-mode autodiff with <code class="docutils literal notranslate"><span class="pre">jvp</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pytrees-and-flattening-user-functions-inputs-and-outputs">Pytrees and flattening user functions‚Äô inputs and outputs</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vectorized-batching-with-vmap">Vectorized batching with <code class="docutils literal notranslate"><span class="pre">vmap</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-2-jaxprs">Part 2: Jaxprs</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#jaxpr-data-structures">Jaxpr data structures</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#building-jaxprs-with-tracing">Building jaxprs with tracing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-3-jit-simplified">Part 3: <code class="docutils literal notranslate"><span class="pre">jit</span></code>, simplified</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#on-the-fly-final-style-and-staged-initial-style-processing">On-the-fly (‚Äúfinal style‚Äù) and staged (‚Äúinitial style‚Äù) processing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-4-linearize-and-vjp-and-grad">Part 4: <code class="docutils literal notranslate"><span class="pre">linearize</span></code> and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> (and <code class="docutils literal notranslate"><span class="pre">grad</span></code>!)</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linearize"><code class="docutils literal notranslate"><span class="pre">linearize</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vjp-and-grad"><code class="docutils literal notranslate"><span class="pre">vjp</span></code> and <code class="docutils literal notranslate"><span class="pre">grad</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-5-the-control-flow-primitives-cond">Part 5: the control flow primitives <code class="docutils literal notranslate"><span class="pre">cond</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adding-cond">Adding <code class="docutils literal notranslate"><span class="pre">cond</span></code></a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <p><a class="reference external" href="https://colab.research.google.com/github/jax-ml/jax/blob/main/docs/autodidax.ipynb"><img alt="Open inColab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a></p>
<section class="tex2jax_ignore mathjax_ignore" id="autodidax-jax-core-from-scratch">
<h1>Autodidax: JAX core from scratch<a class="headerlink" href="#autodidax-jax-core-from-scratch" title="Link to this heading">#</a></h1>
<!--* freshness: { reviewed: '2024-04-08' } *-->
<p>Ever want to learn how JAX works, but the implementation seemed impenetrable?
Well, you‚Äôre in luck! By reading this tutorial, you‚Äôll learn every big idea in
JAX‚Äôs core system. You‚Äôll even get clued into our weird jargon!</p>
<p><strong>This is a work-in-progress draft.</strong> There are some important ingredients
missing, still to come in parts 5 and 6 (and more?). There are also some
simplifications here that we haven‚Äôt yet applied to the main system, but we
will.</p>
<section id="part-1-transformations-as-interpreters-standard-evaluation-jvp-and-vmap">
<h2>Part 1: Transformations as interpreters: standard evaluation, <code class="docutils literal notranslate"><span class="pre">jvp</span></code>, and <code class="docutils literal notranslate"><span class="pre">vmap</span></code><a class="headerlink" href="#part-1-transformations-as-interpreters-standard-evaluation-jvp-and-vmap" title="Link to this heading">#</a></h2>
<p>We want to transform functions that look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>
</pre></div>
</div>
<p>Think of functions like <code class="docutils literal notranslate"><span class="pre">sin</span></code> and the arithmetic operations underlying the
infix operators (<code class="docutils literal notranslate"><span class="pre">mul</span></code>, <code class="docutils literal notranslate"><span class="pre">add</span></code>, and <code class="docutils literal notranslate"><span class="pre">neg</span></code>) as primitive operations, meaning
atomic units of processing rather than compositions.</p>
<p>‚ÄúTransform‚Äù means ‚Äúinterpret differently.‚Äù Instead of standard interpretation
where we apply primitive operations to numerical inputs to produce numerical
outputs, we want to override primitive application and let different values
flow through our program. For example, we might want to replace the
application of every primitive with an application of <a class="reference external" href="https://docs.jax.dev/en/latest/notebooks/autodiff_cookbook.html">its JVP
rule</a>,
and let primal-tangent pairs flow through our program. Moreover, we want to be
able to compose multiple transformations, leading to stacks of interpreters.</p>
<section id="jax-core-machinery">
<h3>JAX core machinery<a class="headerlink" href="#jax-core-machinery" title="Link to this heading">#</a></h3>
<p>We can implement stacks of interpreters and even have them all discharge on
the fly as we execute the Python function to be transformed. To start, let‚Äôs
define these primitives so that we can intercept their application:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>

<span class="k">class</span> <span class="nc">Primitive</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">add_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;add&#39;</span><span class="p">)</span>
<span class="n">mul_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;mul&#39;</span><span class="p">)</span>
<span class="n">neg_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;neg&quot;</span><span class="p">)</span>
<span class="n">sin_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;sin&quot;</span><span class="p">)</span>
<span class="n">cos_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;cos&quot;</span><span class="p">)</span>
<span class="n">reduce_sum_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;reduce_sum&quot;</span><span class="p">)</span>
<span class="n">greater_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;greater&quot;</span><span class="p">)</span>
<span class="n">less_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;less&quot;</span><span class="p">)</span>
<span class="n">transpose_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;transpose&quot;</span><span class="p">)</span>
<span class="n">broadcast_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;broadcast&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">add_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">mul_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">neg</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">neg_p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">sin_p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">cos_p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">greater_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">less_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">transpose_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="n">perm</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">broadcast_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">reduce_sum_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bind1</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="n">out</span><span class="p">,</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</div>
</div>
<p>We‚Äôll set up array data types and infix operator methods in a moment.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">Primitive</span></code> is just an object with a name, to which we attach our
interpretation rules (one for each transformation). The <code class="docutils literal notranslate"><span class="pre">bind</span></code> function is our
interception point: it‚Äôll figure out which transformation rule to apply, based
on how the arguments are boxed in tracers and what interpreters are active.</p>
<p>The functions that user code calls, like <code class="docutils literal notranslate"><span class="pre">add</span></code> and <code class="docutils literal notranslate"><span class="pre">sin</span></code>, are just wrappers
around calls to <code class="docutils literal notranslate"><span class="pre">bind</span></code>. These wrappers let us control how arguments are passed
to <code class="docutils literal notranslate"><span class="pre">bind</span></code>, and in particular we follow a handy internal convention: when we
call <code class="docutils literal notranslate"><span class="pre">bind</span></code>, we pass values representing array data as positional arguments,
and we pass metadata like the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument to <code class="docutils literal notranslate"><span class="pre">reduce_sum_p</span></code> via keyword. This
calling convention simplifies some core logic (since e.g. instances of the
<code class="docutils literal notranslate"><span class="pre">Tracer</span></code> class to be defined below can only occur in positional arguments to
<code class="docutils literal notranslate"><span class="pre">bind</span></code>). The wrappers can also provide docstrings!</p>
<p>We represent active interpreters as a stack. The stack is just a simple
<code class="docutils literal notranslate"><span class="pre">list</span></code>, and each element is a container with an integer level (corresponding
to the element‚Äôs height in the stack), an interpreter type (which we‚Äôll call a
<code class="docutils literal notranslate"><span class="pre">trace_type</span></code>), and an optional field for any global data the interpreter
needs. We call each element a <code class="docutils literal notranslate"><span class="pre">MainTrace</span></code>, though maybe ‚ÄúInterpreter‚Äù would be
more descriptive.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="k">class</span> <span class="nc">MainTrace</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">level</span><span class="p">:</span> <span class="nb">int</span>
  <span class="n">trace_type</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="s1">&#39;Trace&#39;</span><span class="p">]</span>
  <span class="n">global_data</span><span class="p">:</span> <span class="n">Any</span> <span class="o">|</span> <span class="kc">None</span>

<span class="n">trace_stack</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MainTrace</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">dynamic_trace</span><span class="p">:</span> <span class="n">MainTrace</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># to be employed in Part 3</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_main</span><span class="p">(</span><span class="n">trace_type</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="s1">&#39;Trace&#39;</span><span class="p">],</span> <span class="n">global_data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">level</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace_stack</span><span class="p">)</span>
  <span class="n">main</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">trace_type</span><span class="p">,</span> <span class="n">global_data</span><span class="p">)</span>
  <span class="n">trace_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">main</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">trace_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>When we‚Äôre about to apply a transformation, we‚Äôll push another interpreter
onto the stack using <code class="docutils literal notranslate"><span class="pre">new_main</span></code>. Then, as we apply primitives in the function,
we can think of the <code class="docutils literal notranslate"><span class="pre">bind</span></code> first being interpreted by the trace at the top of
the stack (i.e. with the highest level). If that first interpreter itself
binds other primitives in its interpretation rule for the primitive, like how
the JVP rule of <code class="docutils literal notranslate"><span class="pre">sin_p</span></code> might bind <code class="docutils literal notranslate"><span class="pre">cos_p</span></code> and <code class="docutils literal notranslate"><span class="pre">mul_p</span></code>, then those <code class="docutils literal notranslate"><span class="pre">bind</span></code>
calls will be handled by the interpreter at the next level down.</p>
<p>What goes at the bottom of the interpreter stack? At the bottom, we know all
the transformation interpreters are finished, and we just want to do standard
evaluation. So at the bottom we‚Äôll put an evaluation interpreter.</p>
<p>Let‚Äôs sketch out the interface for interpreters, which is based on the <code class="docutils literal notranslate"><span class="pre">Trace</span></code>
and <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> base classes. A <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> represents a boxed-up value, perhaps
carrying some extra context data used by the interpreter. A <code class="docutils literal notranslate"><span class="pre">Trace</span></code> handles
boxing up values into <code class="docutils literal notranslate"><span class="pre">Tracers</span></code> and also handles primitive application.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Trace</span><span class="p">:</span>
  <span class="n">main</span><span class="p">:</span> <span class="n">MainTrace</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main</span><span class="p">:</span> <span class="n">MainTrace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">main</span> <span class="o">=</span> <span class="n">main</span>

  <span class="k">def</span> <span class="nf">pure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span> <span class="k">assert</span> <span class="kc">False</span>  <span class="c1"># must override</span>
  <span class="k">def</span> <span class="nf">lift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span> <span class="k">assert</span> <span class="kc">False</span>  <span class="c1"># must override</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">assert</span> <span class="kc">False</span>  <span class="c1"># must override</span>
</pre></div>
</div>
</div>
</div>
<p>The first two methods are about boxing up values in <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s, which are the
objects that flow through the Python programs we transform. The last method is
the callback we‚Äôll use to interpret primitive application.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Trace</span></code> itself doesn‚Äôt contain any data, other than a reference to its
corresponding <code class="docutils literal notranslate"><span class="pre">MainTrace</span></code> instance. In fact, multiple instances of a <code class="docutils literal notranslate"><span class="pre">Trace</span></code>
might be created and discarded during an application of a transformation,
whereas only a single <code class="docutils literal notranslate"><span class="pre">MainTrace</span></code> instance is created per application of a
transformation.</p>
<p>As for <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s themselves, each one carries an abstract value (and forwards
infix operators to it), and the rest is up to the transformation. (The
relationship between <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s and <code class="docutils literal notranslate"><span class="pre">AbstractValue</span></code>s is that there‚Äôs one
<code class="docutils literal notranslate"><span class="pre">Tracer</span></code> per transformation, and at least one <code class="docutils literal notranslate"><span class="pre">AbstractValue</span></code> per base type,
like arrays.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">Tracer</span><span class="p">:</span>
  <span class="n">_trace</span><span class="p">:</span> <span class="n">Trace</span>

  <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">1000</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">aval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">assert</span> <span class="kc">False</span>  <span class="c1"># must override</span>

  <span class="k">def</span> <span class="nf">full_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># default implementation</span>

  <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_neg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_radd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rmul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> has no attribute </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">f</span><span class="p">):</span> <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ShapedArray</span><span class="p">:</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

  <span class="n">_neg</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span>
  <span class="n">_add</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
  <span class="n">_radd</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">add</span><span class="p">))</span>
  <span class="n">_mul</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">mul</span><span class="p">)</span>
  <span class="n">_rmul</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">mul</span><span class="p">))</span>
  <span class="n">_gt</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">greater</span><span class="p">)</span>
  <span class="n">_lt</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">less</span><span class="p">)</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">_bool</span><span class="p">(</span><span class="n">tracer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ShapedArray can&#39;t be unambiguously converted to bool&quot;</span><span class="p">)</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">_nonzero</span><span class="p">(</span><span class="n">tracer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ShapedArray can&#39;t be unambiguously converted to bool&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s1">]&#39;</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;ShapedArray(shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, dtype=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">)&quot;</span>

<span class="k">class</span> <span class="nc">ConcreteArray</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">):</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">_bool</span><span class="p">(</span><span class="n">tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">_nonzero</span><span class="p">(</span><span class="n">tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span>
  <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jax_types</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ConcreteArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">jax_types</span> <span class="o">=</span> <span class="p">{</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span>
             <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that we actually have two <code class="docutils literal notranslate"><span class="pre">AbstractValue</span></code>s for arrays, representing
different levels of abstraction. A <code class="docutils literal notranslate"><span class="pre">ShapedArray</span></code> represents the set of all
possible arrays with a given shape and dtype. A <code class="docutils literal notranslate"><span class="pre">ConcreteArray</span></code> represents a
singleton set consisting of a single array value.</p>
<p>Now that we‚Äôve set up the interpreter stack, the Trace/Tracer API for
interpreters, and abstract values, we can come back to implement <code class="docutils literal notranslate"><span class="pre">bind</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="n">top_trace</span> <span class="o">=</span> <span class="n">find_top_trace</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">top_trace</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">top_trace</span><span class="o">.</span><span class="n">process_primitive</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">full_lower</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>The main action is that we call <code class="docutils literal notranslate"><span class="pre">find_top_trace</span></code> to figure out which
interpreter should handle this primitive application. We then call that top
trace‚Äôs <code class="docutils literal notranslate"><span class="pre">process_primitive</span></code> so that the trace can apply its interpretation
rule. The calls to <code class="docutils literal notranslate"><span class="pre">full_raise</span></code> just ensure that the inputs are boxed in the
top trace‚Äôs <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> instances, and the call to <code class="docutils literal notranslate"><span class="pre">full_lower</span></code> is an optional
optimization so that we unbox values out of <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s as much as possible.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="nn">op</span>

<span class="k">def</span> <span class="nf">find_top_trace</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Trace</span><span class="p">:</span>
  <span class="n">top_main</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)),</span>
                 <span class="n">default</span><span class="o">=</span><span class="n">trace_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;level&#39;</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">dynamic_trace</span> <span class="ow">and</span> <span class="n">dynamic_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">top_main</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
    <span class="n">top_main</span> <span class="o">=</span> <span class="n">dynamic_trace</span>
  <span class="k">return</span> <span class="n">top_main</span><span class="o">.</span><span class="n">trace_type</span><span class="p">(</span><span class="n">top_main</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In words, ignoring the <code class="docutils literal notranslate"><span class="pre">dynamic_trace</span></code> step until Part 3, <code class="docutils literal notranslate"><span class="pre">find_top_trace</span></code>
returns the highest-level interpreter associated with the <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s on its
inputs, and otherwise returns the interpreter at the bottom of the stack
(which is always an evaluation trace, at least for now). This is a deviation
from the description above, where we always start by running the interpreter
at the top of the stack and then work our way down, applying every interpreter
in the stack. Instead, we‚Äôre only applying an interpreter when the input
arguments to a primitive bind are boxed in a <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> corresponding to that
interpreter. This optimization lets us skip irrelevant transformations, but
bakes in an assumption that transformations mostly follow data dependence
(except for the special bottom-of-the-stack interpreter, which interprets
everything).</p>
<p>An alternative would be to have every interpreter in the stack interpret every
operation. That‚Äôs worth exploring! JAX is designed around data dependence in
large part because that‚Äôs so natural for automatic differentiation, and JAX‚Äôs
roots are in autodiff. But it may be over-fit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">full_lower</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">full_lower</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="k">def</span> <span class="nf">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">:</span> <span class="n">Trace</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tracer</span><span class="p">:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jax_types</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">pure</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="n">level</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">level</span>
  <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span> <span class="ow">is</span> <span class="n">trace</span><span class="o">.</span><span class="n">main</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">val</span>
  <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">lift</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can&#39;t lift level </span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">level</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>  <span class="c1"># val._trace.level == level</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Different traces at same level: </span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">trace</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The logic in <code class="docutils literal notranslate"><span class="pre">full_raise</span></code> serves to box values into <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s for a particular
<code class="docutils literal notranslate"><span class="pre">Trace</span></code>, calling different methods on the <code class="docutils literal notranslate"><span class="pre">Trace</span></code> based on context:
<code class="docutils literal notranslate"><span class="pre">Trace.pure</span></code> is called on non-<code class="docutils literal notranslate"><span class="pre">Tracer</span></code> constants, and <code class="docutils literal notranslate"><span class="pre">Trace.lift</span></code> is called
for values that are already <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s from a lower-level interpreter. These
two methods could share the same implementation, but by distinguishing them in
the core logic we can provide more information to the <code class="docutils literal notranslate"><span class="pre">Trace</span></code> subclass.</p>
<p>That‚Äôs it for the JAX core! Now we can start adding interpreters.</p>
</section>
<section id="evaluation-interpreter">
<h3>Evaluation interpreter<a class="headerlink" href="#evaluation-interpreter" title="Link to this heading">#</a></h3>
<p>We‚Äôll start with the simplest interpreter: the evaluation interpreter that
will sit at the bottom of the interpreter stack.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EvalTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>  <span class="c1"># no boxing in Tracers needed</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">impl_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">](</span><span class="o">*</span><span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

<span class="n">trace_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MainTrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EvalTrace</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>  <span class="c1"># special bottom of the stack</span>

<span class="c1"># NB: in JAX, instead of a dict we attach impl rules to the Primitive instance</span>
<span class="n">impl_rules</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">impl_rules</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">sin_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">cos_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">greater_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">less_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">transpose_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">perm</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">perm</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">broadcast_impl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">broadcast_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast_impl</span>
</pre></div>
</div>
</div>
</div>
<p>With this interpreter, we can evaluate user functions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.7177599838802657
</pre></div>
</div>
</div>
</div>
<p>Woo! Like going around in a big circle. But the point of this indirection is
that now we can add some real transformations.</p>
</section>
<section id="forward-mode-autodiff-with-jvp">
<h3>Forward-mode autodiff with <code class="docutils literal notranslate"><span class="pre">jvp</span></code><a class="headerlink" href="#forward-mode-autodiff-with-jvp" title="Link to this heading">#</a></h3>
<p>First, a few helper functions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">builtins</span>

<span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
  <span class="n">aval</span> <span class="o">=</span> <span class="n">get_aval</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unzip2</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
  <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
    <span class="n">lst1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">lst2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span>

<span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">builtins</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">fst</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">args</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fst</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">rest</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>
  <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">builtins</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> for forward-mode autodiff carries a primal-tangent pair. The
<code class="docutils literal notranslate"><span class="pre">Trace</span></code> applies JVP rules.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">JVPTracer</span><span class="p">(</span><span class="n">Tracer</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">primal</span><span class="p">,</span> <span class="n">tangent</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">primal</span> <span class="o">=</span> <span class="n">primal</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tangent</span> <span class="o">=</span> <span class="n">tangent</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">aval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_aval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">primal</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">JVPTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">JVPTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">primals_in</span><span class="p">,</span> <span class="n">tangents_in</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">primal</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tangent</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">)</span>
    <span class="n">jvp_rule</span> <span class="o">=</span> <span class="n">jvp_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">]</span>
    <span class="n">primal_outs</span><span class="p">,</span> <span class="n">tangent_outs</span> <span class="o">=</span> <span class="n">jvp_rule</span><span class="p">(</span><span class="n">primals_in</span><span class="p">,</span> <span class="n">tangents_in</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">JVPTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">primal_outs</span><span class="p">,</span> <span class="n">tangent_outs</span><span class="p">)]</span>

<span class="n">jvp_rules</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Notice both <code class="docutils literal notranslate"><span class="pre">pure</span></code> and <code class="docutils literal notranslate"><span class="pre">lift</span></code> package a value into a <code class="docutils literal notranslate"><span class="pre">JVPTracer</span></code> with the
minimal amount of context, which is a zero tangent value.</p>
<p>Let‚Äôs add some JVP rules for primitives:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,</span> <span class="n">y_dot</span><span class="p">)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x_dot</span> <span class="o">+</span> <span class="n">y_dot</span><span class="p">]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_jvp</span>

<span class="k">def</span> <span class="nf">mul_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,</span> <span class="n">y_dot</span><span class="p">)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x_dot</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y_dot</span><span class="p">]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">mul_jvp</span>

<span class="k">def</span> <span class="nf">sin_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_dot</span><span class="p">]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">sin_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_jvp</span>

<span class="k">def</span> <span class="nf">cos_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_dot</span><span class="p">]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">cos_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_jvp</span>

<span class="k">def</span> <span class="nf">neg_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">neg</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="n">neg</span><span class="p">(</span><span class="n">x_dot</span><span class="p">)]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_jvp</span>

<span class="k">def</span> <span class="nf">reduce_sum_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)],</span> <span class="p">[</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x_dot</span><span class="p">,</span> <span class="n">axis</span><span class="p">)]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_sum_jvp</span>

<span class="k">def</span> <span class="nf">greater_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="n">out_primal</span> <span class="o">=</span> <span class="n">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">out_primal</span><span class="p">],</span> <span class="p">[</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">out_primal</span><span class="p">)]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">greater_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">greater_jvp</span>

<span class="k">def</span> <span class="nf">less_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="n">out_primal</span> <span class="o">=</span> <span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">out_primal</span><span class="p">],</span> <span class="p">[</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">out_primal</span><span class="p">)]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">less_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">less_jvp</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we add a transformation API to kick off the trace:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jvp_v1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">JVPTrace</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">JVPTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">JVPTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">)]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
    <span class="n">tracer_out</span> <span class="o">=</span> <span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="n">primal_out</span><span class="p">,</span> <span class="n">tangent_out</span> <span class="o">=</span> <span class="n">tracer_out</span><span class="o">.</span><span class="n">primal</span><span class="p">,</span> <span class="n">tracer_out</span><span class="o">.</span><span class="n">tangent</span>
  <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">tangent_out</span>
</pre></div>
</div>
</div>
</div>
<p>And with that, we can differentiate!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="n">y</span><span class="p">,</span> <span class="n">sin_deriv_at_3</span> <span class="o">=</span> <span class="n">jvp_v1</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sin_deriv_at_3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.9899924966004454
-0.9899924966004454
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="n">x</span><span class="p">,</span> <span class="n">xdot</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span>
<span class="n">y</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">jvp_v1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">xdot</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.7177599838802657
2.979984993200891
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">jvp_v1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))[</span><span class="mi">1</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">sin</span><span class="p">)(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">sin</span><span class="p">))(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">sin</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">sin</span><span class="p">))))(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.9899924966004454
-0.1411200080598672
0.9899924966004454
0.1411200080598672
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>  <span class="c1"># Python control flow</span>
    <span class="k">return</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="o">-</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.0
1.0
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="pytrees-and-flattening-user-functions-inputs-and-outputs">
<h2>Pytrees and flattening user functions‚Äô inputs and outputs<a class="headerlink" href="#pytrees-and-flattening-user-functions-inputs-and-outputs" title="Link to this heading">#</a></h2>
<p>A limitation with <code class="docutils literal notranslate"><span class="pre">jvp_v1</span></code> is that it assumes the user function accepts arrays
as positional arguments and produces a single array as output. What if it
produced a list as output? Or accepted nested containers as inputs? It would
be a pain to deal with all the possible containers in inputs and outputs at
every layer of the stack. Instead, we can wrap the user function so that the
wrapped version accepts arrays as inputs and returns a flat list of arrays as
output. The wrapper just needs to unflatten its input, call the user function,
and flatten the output.</p>
<p>Here‚Äôs how we‚Äôd like to write <code class="docutils literal notranslate"><span class="pre">jvp</span></code>, assuming the user always gives us
functions that take arrays as inputs and produces a flat list of arrays as
outputs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jvp_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">JVPTrace</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">JVPTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">JVPTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">)]</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
    <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
    <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">primal</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tangent</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span>
</pre></div>
</div>
</div>
</div>
<p>To support user functions that have arbitrary containers in the inputs and
outputs, here‚Äôs how we‚Äôd write the user-facing <code class="docutils literal notranslate"><span class="pre">jvp</span></code> wrapper:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="n">primals_flat</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">primals</span><span class="p">)</span>
  <span class="n">tangents_flat</span><span class="p">,</span> <span class="n">in_tree2</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">tangents</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">in_tree</span> <span class="o">!=</span> <span class="n">in_tree2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="n">f</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>
  <span class="n">primals_out_flat</span><span class="p">,</span> <span class="n">tangents_out_flat</span> <span class="o">=</span> <span class="n">jvp_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">primals_flat</span><span class="p">,</span> <span class="n">tangents_flat</span><span class="p">)</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">primals_out_flat</span><span class="p">)</span>
  <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">tangents_out_flat</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that we had to plumb the tree structure of the user function output
back to the caller of <code class="docutils literal notranslate"><span class="pre">flatten_fun</span></code>. That information isn‚Äôt available until we
actually run the user function, so <code class="docutils literal notranslate"><span class="pre">flatten_fun</span></code> just returns a reference to a
mutable cell, represented as a thunk. These side-effects are safe because we
always run the user function exactly once. (This safe regime is the reason for
the ‚Äúlinear‚Äù name in <code class="docutils literal notranslate"><span class="pre">linear_util.py</span></code>, in the sense of <a class="reference external" href="https://en.wikipedia.org/wiki/Substructural_type_system">linear
types</a>.)</p>
<p>All that remains is to write <code class="docutils literal notranslate"><span class="pre">tree_flatten</span></code>, <code class="docutils literal notranslate"><span class="pre">tree_unflatten</span></code>, and
<code class="docutils literal notranslate"><span class="pre">flatten_fun</span></code>.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">):</span>
  <span class="n">store</span> <span class="o">=</span> <span class="n">Store</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">flat_fun</span><span class="p">(</span><span class="o">*</span><span class="n">args_flat</span><span class="p">):</span>
    <span class="n">pytree_args</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">in_tree</span><span class="p">,</span> <span class="n">args_flat</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">pytree_args</span><span class="p">)</span>
    <span class="n">out_flat</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="n">store</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">out_tree</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out_flat</span>

  <span class="k">return</span> <span class="n">flat_fun</span><span class="p">,</span> <span class="n">store</span>

<span class="k">class</span> <span class="nc">Empty</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Store</span><span class="p">:</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">empty</span>

  <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">empty</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

  <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>
</pre></div>
</div>
</div>
</details>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">class</span> <span class="nc">NodeType</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
  <span class="n">to_iterable</span><span class="p">:</span> <span class="n">Callable</span>
  <span class="n">from_iterable</span><span class="p">:</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">register_pytree_node</span><span class="p">(</span><span class="n">ty</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span> <span class="n">to_iter</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">from_iter</span><span class="p">:</span> <span class="n">Callable</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
  <span class="n">node_types</span><span class="p">[</span><span class="n">ty</span><span class="p">]</span> <span class="o">=</span> <span class="n">NodeType</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ty</span><span class="p">),</span> <span class="n">to_iter</span><span class="p">,</span> <span class="n">from_iter</span><span class="p">)</span>

<span class="n">node_types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">NodeType</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">register_pytree_node</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">xs</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
<span class="n">register_pytree_node</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span>  <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">xs</span><span class="p">:</span>  <span class="nb">list</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
<span class="n">register_pytree_node</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span>
                     <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">unzip2</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()))),</span>
                     <span class="k">lambda</span> <span class="n">keys</span><span class="p">,</span> <span class="n">vals</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">vals</span><span class="p">)))</span>

<span class="k">class</span> <span class="nc">PyTreeDef</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">node_type</span><span class="p">:</span> <span class="n">NodeType</span>
  <span class="n">node_metadata</span><span class="p">:</span> <span class="n">Hashable</span>
  <span class="n">child_treedefs</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="s1">&#39;PyTreeDef&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Leaf</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">leaf</span> <span class="o">=</span> <span class="n">Leaf</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">tree_flatten</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">PyTreeDef</span><span class="p">]:</span>
  <span class="n">children_iter</span><span class="p">,</span> <span class="n">treedef</span> <span class="o">=</span> <span class="n">_tree_flatten</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">children_iter</span><span class="p">),</span> <span class="n">treedef</span>

<span class="k">def</span> <span class="nf">_tree_flatten</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Iterable</span><span class="p">,</span> <span class="n">PyTreeDef</span><span class="p">]:</span>
  <span class="n">node_type</span> <span class="o">=</span> <span class="n">node_types</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">node_type</span><span class="p">:</span>
    <span class="n">node_metadata</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">node_type</span><span class="o">.</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">children_flat</span><span class="p">,</span> <span class="n">child_trees</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_tree_flatten</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
    <span class="n">flattened</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">children_flat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flattened</span><span class="p">,</span> <span class="n">PyTreeDef</span><span class="p">(</span><span class="n">node_type</span><span class="p">,</span> <span class="n">node_metadata</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">child_trees</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">leaf</span>

<span class="k">def</span> <span class="nf">tree_unflatten</span><span class="p">(</span><span class="n">treedef</span><span class="p">:</span> <span class="n">PyTreeDef</span><span class="p">,</span> <span class="n">xs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">_tree_unflatten</span><span class="p">(</span><span class="n">treedef</span><span class="p">,</span> <span class="nb">iter</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_tree_unflatten</span><span class="p">(</span><span class="n">treedef</span><span class="p">:</span> <span class="n">PyTreeDef</span><span class="p">,</span> <span class="n">xs</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">treedef</span> <span class="ow">is</span> <span class="n">leaf</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">_tree_unflatten</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">treedef</span><span class="o">.</span><span class="n">child_treedefs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">treedef</span><span class="o">.</span><span class="n">node_type</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">treedef</span><span class="o">.</span><span class="n">node_metadata</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>With this pytree-handling <code class="docutils literal notranslate"><span class="pre">jvp</span></code> implementation, we can now handle arbitrary
input and output containers. That‚Äôll come in handy with future transformations
too!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;hi&#39;</span><span class="p">:</span> <span class="n">z</span><span class="p">,</span> <span class="s1">&#39;there&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]}</span>

<span class="n">x</span><span class="p">,</span> <span class="n">xdot</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span>
<span class="n">y</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">xdot</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;hi&#39;: np.float64(2.7177599838802657), &#39;there&#39;: [3.0, np.float64(0.2822400161197344)]}
{&#39;hi&#39;: np.float64(2.979984993200891), &#39;there&#39;: [1.0, np.float64(-1.9799849932008908)]}
</pre></div>
</div>
</div>
</div>
<section id="vectorized-batching-with-vmap">
<h3>Vectorized batching with <code class="docutils literal notranslate"><span class="pre">vmap</span></code><a class="headerlink" href="#vectorized-batching-with-vmap" title="Link to this heading">#</a></h3>
<p>First, a couple helper functions, one for producing mapped abstract values
from unmapped ones (by removing an axis), and one for moving batch dimensions
around:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mapped_aval</span><span class="p">(</span><span class="n">batch_dim</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">shape</span><span class="p">[</span><span class="n">batch_dim</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">move_batch_axis</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">src</span> <span class="ow">is</span> <span class="n">not_mapped</span><span class="p">:</span>
    <span class="n">target_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">target_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">target_shape</span><span class="p">,</span> <span class="p">[</span><span class="n">dst</span><span class="p">])</span>
  <span class="k">elif</span> <span class="n">src</span> <span class="o">==</span> <span class="n">dst</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">src</span><span class="p">]</span>
  <span class="n">perm</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> for vectorized batching carries a batched value and an optional
integer indicating which axis (if any) is the batch axis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="k">class</span> <span class="nc">NotMapped</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">not_mapped</span> <span class="o">=</span> <span class="n">NotMapped</span><span class="p">()</span>

<span class="n">BatchAxis</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">NotMapped</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">BatchTracer</span><span class="p">(</span><span class="n">Tracer</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">batch_dim</span><span class="p">:</span> <span class="n">BatchAxis</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">batch_dim</span> <span class="o">=</span> <span class="n">batch_dim</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">aval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_dim</span> <span class="ow">is</span> <span class="n">not_mapped</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">get_aval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">mapped_aval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_dim</span><span class="p">,</span> <span class="n">get_aval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">full_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_dim</span> <span class="ow">is</span> <span class="n">not_mapped</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">full_lower</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">BatchTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">BatchTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">not_mapped</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">vals_in</span><span class="p">,</span> <span class="n">bdims_in</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">batch_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">)</span>
    <span class="n">vmap_rule</span> <span class="o">=</span> <span class="n">vmap_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">]</span>
    <span class="n">val_outs</span><span class="p">,</span> <span class="n">bdim_outs</span> <span class="o">=</span> <span class="n">vmap_rule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">bdims_in</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">BatchTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bd</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">bd</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">val_outs</span><span class="p">,</span> <span class="n">bdim_outs</span><span class="p">)]</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">axis_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">global_data</span>

<span class="n">vmap_rules</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Here we‚Äôve implemented the optional <code class="docutils literal notranslate"><span class="pre">Tracer.full_lower</span></code> method, which lets us
peel off a batching tracer if it‚Äôs not needed because it doesn‚Äôt represent a
batched value.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">BatchTrace</span></code>, analogous to <code class="docutils literal notranslate"><span class="pre">JVPTrace</span></code>, the methods <code class="docutils literal notranslate"><span class="pre">pure</span></code> and <code class="docutils literal notranslate"><span class="pre">lift</span></code> just
box a value in a <code class="docutils literal notranslate"><span class="pre">BatchTracer</span></code> with the minimal amount of context, which in
this case is a <code class="docutils literal notranslate"><span class="pre">batch_dim</span></code> taking the sentinel value <code class="docutils literal notranslate"><span class="pre">not_mapped</span></code>. Notice we
use the <code class="docutils literal notranslate"><span class="pre">MainTrace</span></code>‚Äôs interpreter-global data field to store the batch axis
size.</p>
<p>Next we can define batching interpreter rules for each primitive:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="k">def</span> <span class="nf">binop_batching_rule</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x_bdim</span><span class="p">,</span> <span class="n">y_bdim</span><span class="p">)</span> <span class="o">=</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span>
  <span class="k">if</span> <span class="n">x_bdim</span> <span class="o">!=</span> <span class="n">y_bdim</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x_bdim</span> <span class="ow">is</span> <span class="n">not_mapped</span><span class="p">:</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">move_batch_axis</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">x_bdim</span><span class="p">,</span> <span class="n">y_bdim</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
      <span class="n">x_bdim</span> <span class="o">=</span> <span class="n">y_bdim</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">move_batch_axis</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">y_bdim</span><span class="p">,</span> <span class="n">x_bdim</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)],</span> <span class="p">[</span><span class="n">x_bdim</span><span class="p">]</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">binop_batching_rule</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">binop_batching_rule</span><span class="p">,</span> <span class="n">mul</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vectorized_unop_batching_rule</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_bdim</span><span class="p">,)</span> <span class="o">=</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="n">x_bdim</span><span class="p">]</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">sin_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">vectorized_unop_batching_rule</span><span class="p">,</span> <span class="n">sin</span><span class="p">)</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">cos_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">vectorized_unop_batching_rule</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">vectorized_unop_batching_rule</span><span class="p">,</span> <span class="n">neg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">reduce_sum_batching_rule</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_bdim</span><span class="p">,)</span> <span class="o">=</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span>
  <span class="n">new_axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ax</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_bdim</span> <span class="o">&lt;=</span> <span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>
  <span class="n">out_bdim</span> <span class="o">=</span> <span class="n">x_bdim</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ax</span> <span class="o">&lt;</span> <span class="n">x_bdim</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_axis</span><span class="p">)],</span> <span class="p">[</span><span class="n">out_bdim</span><span class="p">]</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_sum_batching_rule</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we add a transformation API to kick off the trace:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vmap_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_axes</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">axis_size</span><span class="p">,</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">in_axes</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">not_mapped</span><span class="p">}</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">BatchTrace</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">BatchTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">BatchTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span>
                  <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">in_axes</span><span class="p">)]</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
    <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
    <span class="n">vals_out</span><span class="p">,</span> <span class="n">bdims_out</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">batch_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span><span class="p">)</span>
  <span class="n">outs_transposed</span> <span class="o">=</span> <span class="p">[</span><span class="n">move_batch_axis</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">bdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val_out</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">val_out</span><span class="p">,</span> <span class="n">bdim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vals_out</span><span class="p">,</span> <span class="n">bdims_out</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">outs_transposed</span>

<span class="k">def</span> <span class="nf">vmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_axes</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">batched_f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args_flat</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">in_axes_flat</span><span class="p">,</span> <span class="n">in_tree2</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">in_axes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">in_tree</span> <span class="o">!=</span> <span class="n">in_tree2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="n">f_flat</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>
    <span class="n">outs_flat</span> <span class="o">=</span> <span class="n">vmap_flat</span><span class="p">(</span><span class="n">f_flat</span><span class="p">,</span> <span class="n">in_axes_flat</span><span class="p">,</span> <span class="o">*</span><span class="n">args_flat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">outs_flat</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">batched_f</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_one_to_a_scalar</span><span class="p">(</span><span class="n">scalar</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">scalar</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">scalar</span>

<span class="n">vector_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">vector_out</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">add_one_to_a_scalar</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))(</span><span class="n">vector_in</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">vector_in</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vector_out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0. 1. 2.]
[1. 2. 3.]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jacfwd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">pushfwd</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">v</span><span class="p">,))[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">vecs_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">vmap</span><span class="p">(</span><span class="n">pushfwd</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))(</span><span class="n">vecs_in</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">jacfwd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[ 1.        ,  0.        , -0.        ],
       [ 0.        ,  0.54030231, -0.        ],
       [ 0.        ,  0.        , -0.41614684]])
</pre></div>
</div>
</div>
</div>
<p>That‚Äôs it for <code class="docutils literal notranslate"><span class="pre">jvp</span></code> and <code class="docutils literal notranslate"><span class="pre">vmap</span></code>!</p>
</section>
</section>
<section id="part-2-jaxprs">
<h2>Part 2: Jaxprs<a class="headerlink" href="#part-2-jaxprs" title="Link to this heading">#</a></h2>
<p>The next transformations on the horizon are <code class="docutils literal notranslate"><span class="pre">jit</span></code> for just-in-time
compilation and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> for reverse-mode autodiff.  (<code class="docutils literal notranslate"><span class="pre">grad</span></code> is just a small
wrapper around <code class="docutils literal notranslate"><span class="pre">vjp</span></code>.) Whereas <code class="docutils literal notranslate"><span class="pre">jvp</span></code> and <code class="docutils literal notranslate"><span class="pre">vmap</span></code> only needed each <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> to
carry a little bit of extra context, for both <code class="docutils literal notranslate"><span class="pre">jit</span></code> and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> we need much
richer context: we need to represent <em>programs</em>. That is, we need jaxprs!</p>
<p>Jaxprs are JAX‚Äôs internal intermediate representation of programs. They are
explicitly typed, functional, first-order, and in ANF form. We need a
program representation for <code class="docutils literal notranslate"><span class="pre">jit</span></code> because the purpose of <code class="docutils literal notranslate"><span class="pre">jit</span></code> is to stage
computation out of Python. For any computation we want to stage out, we need
to be able to represent it as data, and build it up as we trace a Python
function. Similarly, <code class="docutils literal notranslate"><span class="pre">vjp</span></code> needs a way to represent the computation for the
backward pass of reverse-mode autodiff. We use the same jaxpr program
representation for both needs.</p>
<p>(Building a program representation is the most
<a class="reference external" href="https://en.wikipedia.org/wiki/Free_object">free</a> kind of
trace-transformation, and so except for issues around handling native Python
control flow, any transformation could be implemented by first tracing to a
jaxpr and then interpreting the jaxpr.)</p>
<section id="jaxpr-data-structures">
<h3>Jaxpr data structures<a class="headerlink" href="#jaxpr-data-structures" title="Link to this heading">#</a></h3>
<p>The jaxpr term syntax is roughly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jaxpr</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">{</span> <span class="k">lambda</span> <span class="o">&lt;</span><span class="n">binder</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span> <span class="o">.</span>
    <span class="n">let</span> <span class="o">&lt;</span><span class="n">eqn</span><span class="o">&gt;</span>
        <span class="o">...</span>
    <span class="ow">in</span> <span class="p">(</span> <span class="o">&lt;</span><span class="n">atom</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span> <span class="p">)</span> <span class="p">}</span>

<span class="n">binder</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span><span class="p">:</span><span class="o">&lt;</span><span class="n">array_type</span><span class="o">&gt;</span>
<span class="n">var</span> <span class="p">:</span><span class="o">:=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="o">|</span> <span class="n">c</span> <span class="o">|</span> <span class="o">...</span>
<span class="n">atom</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">literal</span><span class="o">&gt;</span>
<span class="n">literal</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">float32</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">float64</span><span class="o">&gt;</span>

<span class="n">eqn</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">binder</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">primitive</span><span class="o">&gt;</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">params</span><span class="o">&gt;</span> <span class="p">]</span> <span class="o">&lt;</span><span class="n">atom</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>The syntax of types is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jaxpr_type</span> <span class="p">:</span><span class="o">:=</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">array_type</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span> <span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">array_type</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span> <span class="p">]</span>
<span class="n">array_type</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">dtype</span><span class="o">&gt;</span><span class="p">[</span><span class="o">&lt;</span><span class="n">shape</span><span class="o">&gt;</span><span class="p">]</span>
<span class="n">dtype</span> <span class="p">:</span><span class="o">:=</span> <span class="n">f32</span> <span class="o">|</span> <span class="n">f64</span> <span class="o">|</span> <span class="n">i32</span> <span class="o">|</span> <span class="n">i64</span>
<span class="n">shape</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>How do we represent these as Python data structures? We reuse ShapedArrays to
represent types, and we can represent the term syntax with a few Python
structs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Var</span><span class="p">:</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span>

<span class="k">class</span> <span class="nc">Lit</span><span class="p">:</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">Any</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span> <span class="o">=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="n">Atom</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Lit</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">JaxprEqn</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">primitive</span><span class="p">:</span> <span class="n">Primitive</span>
  <span class="n">inputs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span>
  <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
  <span class="n">out_binders</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Jaxpr</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">in_binders</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>
  <span class="n">eqns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">]</span>
  <span class="n">outs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="fm">__eq__</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">is_</span>

<span class="k">def</span> <span class="nf">raise_to_shaped</span><span class="p">(</span><span class="n">aval</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Type-checking a jaxpr involves checking that there are no unbound variables,
that variables are only bound once, and that for each equation the type of
the primitive application matches the type of the output binders.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">JaxprType</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">in_types</span><span class="p">:</span>  <span class="nb">list</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]</span>
  <span class="n">out_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">in_types</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">str_short</span><span class="p">()</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_types</span><span class="p">)</span>
    <span class="n">out_types</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">str_short</span><span class="p">()</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_types</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">in_types</span><span class="si">}</span><span class="s1">) -&gt; (</span><span class="si">{</span><span class="n">out_types</span><span class="si">}</span><span class="s1">)&#39;</span>

<span class="k">def</span> <span class="nf">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprType</span><span class="p">:</span>
  <span class="n">env</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="n">env</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="n">in_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">typecheck_atom</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>
    <span class="n">out_types</span> <span class="o">=</span> <span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">](</span><span class="o">*</span><span class="n">in_types</span><span class="p">,</span> <span class="o">**</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">out_binder</span><span class="p">,</span> <span class="n">out_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">,</span> <span class="n">out_types</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">out_type</span> <span class="o">==</span> <span class="n">out_binder</span><span class="o">.</span><span class="n">aval</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="k">for</span> <span class="n">out_binder</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">out_binder</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
      <span class="n">env</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">out_binder</span><span class="p">)</span>

  <span class="n">in_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">]</span>
  <span class="n">out_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">typecheck_atom</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">JaxprType</span><span class="p">(</span><span class="n">in_types</span><span class="p">,</span> <span class="n">out_types</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">typecheck_atom</span><span class="p">(</span><span class="n">env</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Var</span><span class="p">],</span> <span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unbound variable&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Lit</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<p>We can apply the function represented by a jaxpr to arguments with a simple
interpreter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
  <span class="n">env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">env</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span>

  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">env</span>  <span class="c1"># single-assignment</span>
    <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

  <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="n">in_vals</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="o">*</span><span class="n">in_vals</span><span class="p">,</span> <span class="o">**</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">jaxpr_as_fun</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">):</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>By using <code class="docutils literal notranslate"><span class="pre">bind</span></code> in the interpreter, this interpreter itself is traceable.</p>
</section>
<section id="building-jaxprs-with-tracing">
<h3>Building jaxprs with tracing<a class="headerlink" href="#building-jaxprs-with-tracing" title="Link to this heading">#</a></h3>
<p>Now that we have jaxprs as a data structure, we need ways to produce these
from tracing Python code. In general there are two variants of how we trace to
a jaxpr; <code class="docutils literal notranslate"><span class="pre">jit</span></code> uses one and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> uses the other. We‚Äôll start with the one
used by <code class="docutils literal notranslate"><span class="pre">jit</span></code>, which is also used by control flow primitives like <code class="docutils literal notranslate"><span class="pre">lax.cond</span></code>,
<code class="docutils literal notranslate"><span class="pre">lax.while_loop</span></code>, and <code class="docutils literal notranslate"><span class="pre">lax.scan</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">split_list</span><span class="p">(</span><span class="n">lst</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lst</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">partition_list</span><span class="p">(</span><span class="n">bs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
  <span class="n">lists</span> <span class="o">=</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="n">lists</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NB: the analogous class in JAX is called &#39;DynamicJaxprTracer&#39;</span>
<span class="k">class</span> <span class="nc">JaxprTracer</span><span class="p">(</span><span class="n">Tracer</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;aval&#39;</span><span class="p">]</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span>

<span class="c1"># NB: the analogous class in JAX is called &#39;DynamicJaxprTrace&#39;</span>
<span class="k">class</span> <span class="nc">JaxprTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">new_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprTracer</span><span class="p">:</span>
    <span class="n">aval</span> <span class="o">=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
    <span class="n">tracer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">new_tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">tracer</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tracer</span>

  <span class="k">def</span> <span class="nf">get_or_make_const_tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprTracer</span><span class="p">:</span>
    <span class="n">tracer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">const_tracers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">tracer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">tracer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">new_tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">add_const</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tracer</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">=</span> <span class="n">get_or_make_const_tracer</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">avals_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>
    <span class="n">avals_out</span> <span class="o">=</span> <span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">](</span><span class="o">*</span><span class="n">avals_in</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">out_tracers</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">new_tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">avals_out</span><span class="p">]</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">getvar</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>
    <span class="n">outvars</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">out_tracers</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">add_eqn</span><span class="p">(</span><span class="n">JaxprEqn</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">outvars</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out_tracers</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">builder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">global_data</span>

<span class="c1"># NB: in JAX, we instead attach abstract eval rules to Primitive instances</span>
<span class="n">abstract_eval_rules</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that we keep as interpreter-global data a builder object, which keeps
track of variables, constants, and eqns as we build up the jaxpr.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">JaxprBuilder</span><span class="p">:</span>
  <span class="n">eqns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">]</span>
  <span class="n">tracer_to_var</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Var</span><span class="p">]</span>
  <span class="n">const_tracers</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">JaxprTracer</span><span class="p">]</span>
  <span class="n">constvals</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
  <span class="n">tracers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">JaxprTracer</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tracer_to_var</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">const_tracers</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">constvals</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">new_tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">:</span> <span class="n">JaxprTrace</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprTracer</span><span class="p">:</span>
    <span class="n">tracer</span> <span class="o">=</span> <span class="n">JaxprTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tracer</span>

  <span class="k">def</span> <span class="nf">add_eqn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqn</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">add_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">:</span> <span class="n">JaxprTracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Var</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_to_var</span>
    <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">tracer</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">var</span>

  <span class="k">def</span> <span class="nf">getvar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">:</span> <span class="n">JaxprTracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Var</span><span class="p">:</span>
    <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_to_var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">tracer</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">var</span>

  <span class="k">def</span> <span class="nf">add_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">:</span> <span class="n">JaxprTracer</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Var</span><span class="p">:</span>
    <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">const_tracers</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span> <span class="o">=</span> <span class="n">tracer</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">constvals</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">var</span>

  <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_tracers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">JaxprTracer</span><span class="p">],</span> <span class="n">out_tracers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">JaxprTracer</span><span class="p">]</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
    <span class="n">constvars</span><span class="p">,</span> <span class="n">constvals</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constvals</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="n">t2v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>
    <span class="n">in_binders</span> <span class="o">=</span> <span class="n">constvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">t2v</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">in_tracers</span><span class="p">]</span>
    <span class="n">out_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">t2v</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">out_tracers</span><span class="p">]</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">in_binders</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">out_vars</span><span class="p">)</span>
    <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">constvals</span> <span class="o">=</span> <span class="n">_inline_literals</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">constvals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">constvals</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_inline_literals</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="n">const_binders</span><span class="p">,</span> <span class="n">other_binders</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">consts</span><span class="p">))</span>
  <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jax_types</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">]</span>
  <span class="n">new_const_binders</span><span class="p">,</span> <span class="n">lit_binders</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">const_binders</span><span class="p">)</span>
  <span class="n">new_consts</span><span class="p">,</span> <span class="n">lit_vals</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">consts</span><span class="p">)</span>
  <span class="n">literals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lit_binders</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">Lit</span><span class="p">,</span> <span class="n">lit_vals</span><span class="p">)))</span>
  <span class="n">new_eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">JaxprEqn</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="p">[</span><span class="n">literals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">],</span>
                       <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span> <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">]</span>
  <span class="n">new_outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">literals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">]</span>
  <span class="n">new_jaxpr</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">new_const_binders</span> <span class="o">+</span> <span class="n">other_binders</span><span class="p">,</span> <span class="n">new_eqns</span><span class="p">,</span> <span class="n">new_outs</span><span class="p">)</span>
  <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">new_jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span>
</pre></div>
</div>
</div>
</div>
<p>The rules we need for <code class="docutils literal notranslate"><span class="pre">JaxprTrace.process_primitive</span></code> are essentially typing
rules for primitive applications: given the primitive, its parameters, and
types for the inputs, the rule must produce a type for the output, which is
then packaged with the output <code class="docutils literal notranslate"><span class="pre">JaxprTracer</span></code>. We can use abstract evaluation
rules for this same purpose, even though they can be more general (since
abstract evaluation rules must accept ConcreteArray inputs, and since they
need only return an upper bound on the set of possible outputs, they can
produce ConcreteArray outputs as well). We‚Äôll reuse these abstract evaluation
rules for the other jaxpr-producing trace machinery, where the potential extra
generality is useful.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">binop_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">y</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">ShapedArray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span>

<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">binop_abstract_eval</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">binop_abstract_eval</span>

<span class="k">def</span> <span class="nf">compare_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">ShapedArray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">))]</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">greater_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">compare_abstract_eval</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">less_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">compare_abstract_eval</span>

<span class="k">def</span> <span class="nf">vectorized_unop_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">ShapedArray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span>

<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">sin_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">vectorized_unop_abstract_eval</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">cos_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">vectorized_unop_abstract_eval</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">vectorized_unop_abstract_eval</span>

<span class="k">def</span> <span class="nf">reduce_sum_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="n">axis_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axis_</span><span class="p">]</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">ShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_sum_abstract_eval</span>

<span class="k">def</span> <span class="nf">broadcast_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                            <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">ShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">broadcast_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast_abstract_eval</span>
</pre></div>
</div>
</div>
</div>
<p>To check our implementation of jaxprs, we can add a <code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code>
transformation and a pretty-printer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>

<span class="nd">@lru_cache</span>  <span class="c1"># ShapedArrays are hashable</span>
<span class="k">def</span> <span class="nf">make_jaxpr_v1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">avals_in</span><span class="p">):</span>
  <span class="n">avals_in</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">avals_in</span><span class="p">)</span>
  <span class="n">f</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>

  <span class="n">builder</span> <span class="o">=</span> <span class="n">JaxprBuilder</span><span class="p">()</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">JaxprTrace</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">JaxprTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">new_arg</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">avals_in</span><span class="p">]</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
    <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">tracers_in</span><span class="p">,</span> <span class="n">tracers_out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">out_tree</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">string</span>

<span class="k">class</span> <span class="nc">PPrint</span><span class="p">:</span>
  <span class="n">lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span>

  <span class="k">def</span> <span class="nf">indent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;PPrint&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">PPrint</span><span class="p">([(</span><span class="n">indent</span> <span class="o">+</span> <span class="n">orig_indent</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">orig_indent</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">])</span>

  <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="s1">&#39;PPrint&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;PPrint&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">PPrint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">lines</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="s1">&#39;PPrint&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;PPrint&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rhs</span><span class="o">.</span><span class="n">lines</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">:</span> <span class="k">return</span> <span class="n">rhs</span>
    <span class="n">indent</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">indented_block</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="n">common_line</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">rhs</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">PPrint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                  <span class="o">+</span> <span class="p">[(</span><span class="n">indent</span><span class="p">,</span> <span class="n">common_line</span><span class="p">)]</span>
                  <span class="o">+</span> <span class="n">indented_block</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">indent</span> <span class="o">+</span> <span class="n">s</span> <span class="k">for</span> <span class="n">indent</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pp</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">PPrint</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()])</span>

<span class="k">def</span> <span class="nf">vcat</span><span class="p">(</span><span class="n">ps</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">PPrint</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">pp</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pp_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="n">namegen</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
  <span class="n">names</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">namegen</span><span class="p">))</span>
  <span class="n">in_binders</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">var_str</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">)</span>
  <span class="n">eqns</span> <span class="o">=</span> <span class="n">vcat</span><span class="p">([</span><span class="n">pp_eqn</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">])</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Var</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">pp</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">{{</span><span class="s1"> lambda </span><span class="si">{</span><span class="n">in_binders</span><span class="si">}</span><span class="s1"> .&#39;</span><span class="p">)</span> <span class="o">+</span>
          <span class="p">((</span><span class="n">pp</span><span class="p">(</span><span class="s1">&#39;let &#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">eqns</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;in ( </span><span class="si">{</span><span class="n">outs</span><span class="si">}</span><span class="s1"> ) </span><span class="se">}}</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">var_str</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">names</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">str_short</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>

<span class="k">def</span> <span class="nf">pp_eqn</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="n">rule</span> <span class="o">=</span> <span class="n">pp_rules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">rule</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">rule</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">eqn</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">lhs</span> <span class="o">=</span> <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">var_str</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">))</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">pp_params</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
           <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Var</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">lhs</span> <span class="o">&gt;&gt;</span> <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; = &#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">pp_params</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
  <span class="k">if</span> <span class="n">items</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; [ &#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">vcat</span><span class="p">([</span><span class="n">pp</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; ] &#39;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>

<span class="n">Jaxpr</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp_jaxpr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
<span class="n">pp_rules</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Primitive</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">PPrint</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</details>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr_v1</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="mf">3.</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{ lambda a:float64[] .
  let b:float64[] = mul 2.0 a
  in ( b ) }
(float64[]) -&gt; (float64[])
</pre></div>
</div>
</div>
</div>
<p>But there‚Äôs a limitation here: because of how <code class="docutils literal notranslate"><span class="pre">find_top_trace</span></code> operates by
data dependence, <code class="docutils literal notranslate"><span class="pre">make_jaxpr_v1</span></code> can‚Äôt stage out all the primitive operations
performed by the Python callable it‚Äôs given. For example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr_v1</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{ lambda  .
  let 
  in ( 4.0 ) }
</pre></div>
</div>
</div>
</div>
<p>This is precisely the issue that
<a class="reference external" href="https://github.com/jax-ml/jax/pull/3370">omnistaging</a> fixed.
We want to ensure that the <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code> started by <code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code> is always
applied, regardless of whether any inputs to <code class="docutils literal notranslate"><span class="pre">bind</span></code> are boxed in corresponding
<code class="docutils literal notranslate"><span class="pre">JaxprTracer</span></code> instances. We can achieve this by employing the <code class="docutils literal notranslate"><span class="pre">dynamic_trace</span></code>
global defined in Part 1:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_dynamic</span><span class="p">(</span><span class="n">main</span><span class="p">:</span> <span class="n">MainTrace</span><span class="p">):</span>
  <span class="k">global</span> <span class="n">dynamic_trace</span>
  <span class="n">prev_dynamic_trace</span><span class="p">,</span> <span class="n">dynamic_trace</span> <span class="o">=</span> <span class="n">dynamic_trace</span><span class="p">,</span> <span class="n">main</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">dynamic_trace</span> <span class="o">=</span> <span class="n">prev_dynamic_trace</span>

<span class="nd">@lru_cache</span>
<span class="k">def</span> <span class="nf">make_jaxpr</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">avals_in</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span>
               <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">PyTreeDef</span><span class="p">]:</span>
  <span class="n">avals_in</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">avals_in</span><span class="p">)</span>
  <span class="n">f</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>

  <span class="n">builder</span> <span class="o">=</span> <span class="n">JaxprBuilder</span><span class="p">()</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">JaxprTrace</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">new_dynamic</span><span class="p">(</span><span class="n">main</span><span class="p">):</span>
      <span class="n">trace</span> <span class="o">=</span> <span class="n">JaxprTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
      <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">new_arg</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">avals_in</span><span class="p">]</span>
      <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
      <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
      <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">tracers_in</span><span class="p">,</span> <span class="n">tracers_out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">out_tree</span><span class="p">()</span>

<span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{ lambda  .
  let a:float64[] = mul 2.0 2.0
  in ( a ) }
</pre></div>
</div>
</div>
</div>
<p>Using <code class="docutils literal notranslate"><span class="pre">dynamic_trace</span></code> this way is conceptually the same as stashing the
current interpreter stack and starting a new one with the <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code> at the
bottom. That is, no interpreters lower in the stack than the <code class="docutils literal notranslate"><span class="pre">dynamic_trace</span></code>
are applied (since <code class="docutils literal notranslate"><span class="pre">JaxprTrace.process_primitive</span></code> doesn‚Äôt call <code class="docutils literal notranslate"><span class="pre">bind</span></code>), though
if the Python callable being traced to a jaxpr itself uses transformations
then those can be pushed onto the interpreter stack above the <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code>.
But temporarily stashing the interpreter stack would break up the system
state. The <code class="docutils literal notranslate"><span class="pre">dynamic_trace</span></code> tag achieves the same goals while keeping the
system state simpler.</p>
<p>That‚Äôs it for jaxprs! With jaxprs in hand, we can implement the remaining
major JAX features.</p>
</section>
</section>
<section id="part-3-jit-simplified">
<h2>Part 3: <code class="docutils literal notranslate"><span class="pre">jit</span></code>, simplified<a class="headerlink" href="#part-3-jit-simplified" title="Link to this heading">#</a></h2>
<p>While <code class="docutils literal notranslate"><span class="pre">jit</span></code> has a transformation-like API in that it accepts a Python callable
as an argument, under the hood it‚Äôs really a higher-order primitive rather
than a transformation. A primitive is <em>higher-order</em> when it‚Äôs parameterized
by a function.</p>
<section id="on-the-fly-final-style-and-staged-initial-style-processing">
<h3>On-the-fly (‚Äúfinal style‚Äù) and staged (‚Äúinitial style‚Äù) processing<a class="headerlink" href="#on-the-fly-final-style-and-staged-initial-style-processing" title="Link to this heading">#</a></h3>
<p>There are two options for how to handle higher-order primitives. Each requires
a different approach to tracing and engenders different tradeoffs:</p>
<ol class="arabic simple">
<li><p><strong>On-the-fly processing, where <code class="docutils literal notranslate"><span class="pre">bind</span></code> takes a Python callable as an
argument.</strong> We defer forming a jaxpr until as late as possible, namely
until we‚Äôre running the final interpreter at the bottom of the interpreter
stack. That way we can swap a <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code> in at the bottom of the
interpreter stack and thus stage out rather than execute all primitive
operations. With this approach, transformations in the stack get applied as
we execute the Python callable as usual. This approach can be very tricky
to implement, but it‚Äôs as general as possible because it allows
higher-order primitives not to raise the abstraction level of their
arguments and thus allows data-dependent Python control flow. We refer to
this approach as using a ‚Äúfinal-style higher-order primitive‚Äù employing the
discharge-at-tracing-time ‚Äúfinal-style transformations‚Äù we‚Äôve used so far.</p></li>
<li><p><strong>Staged processing, where <code class="docutils literal notranslate"><span class="pre">bind</span></code> takes a jaxpr as an argument.</strong> Before we
call <code class="docutils literal notranslate"><span class="pre">bind</span></code>, in the primitive wrapper we can just use <code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code> to form
a jaxpr up-front and be done with the Python callable entirely. In this
case, <code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code> puts its <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code> at the top of the interpreter
stack, and no transformations lower in the stack, which might enter via
closed-over Tracers, are applied to the Python callable as we trace it.
(Transformations applied within the Python callable are applied as usual,
being added to the stack above the JaxprTrace.) Instead, the
transformations lower in the stack are later applied to the call primitive,
and the call primitive‚Äôs rules must then transform the jaxpr itself.
Because we trace to a jaxpr up-front, this approach can‚Äôt support
data-dependent Python control flow, but it is more straightforward to
implement. We refer to this kind of higher-order primitive as an
‚Äúinitial-style higher-order primitive‚Äù, and say that its jaxpr-processing
transformation rules are ‚Äúinitial-style transformation rules.‚Äù</p></li>
</ol>
<p>The latter approach fits for <code class="docutils literal notranslate"><span class="pre">jit</span></code> because we don‚Äôt need to support
data-dependent Python control flow in the user-provided Python callable, as
the whole purpose of <code class="docutils literal notranslate"><span class="pre">jit</span></code> is to stage computation out of Python to be
executed by XLA. (In contrast, <code class="docutils literal notranslate"><span class="pre">custom_jvp</span></code> is a higher-order primitive in
which we want to support data-dependent Python control flow.)</p>
<p>Historically, we started using the ‚Äúinitial-style‚Äù and ‚Äúfinal-style‚Äù
terminology after reading the <a class="reference external" href="http://okmij.org/ftp/tagless-final/index.html">typed tagless final
interpreters</a> paper, and
jokingly referring to JAX as an implementation of ‚Äúuntyped tagful final
interpreters.‚Äù We don‚Äôt claim to carry over (or understand) any deep meaning
behind these terms; we loosely use ‚Äúinitial style‚Äù to mean ‚Äúbuild an AST and
then transform it‚Äù, and we use ‚Äúfinal style‚Äù to mean ‚Äútransform as we trace.‚Äù
But it‚Äôs just imprecise yet sticky jargon.</p>
<p>With the initial-style approach, here‚Äôs the user-facing <code class="docutils literal notranslate"><span class="pre">jit</span></code> wrapper:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jit</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">f_jitted</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">avals_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">avals_in</span><span class="p">)</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">consts</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">f_jitted</span>

<span class="n">xla_call_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;xla_call&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>With any new primitive, we need to give it transformation rules, starting with
its evaluation rule. When we evaluate an application of the <code class="docutils literal notranslate"><span class="pre">xla_call</span></code>
primitive, we want to stage out the computation to XLA. That involves
translating the jaxpr to an XLA HLO program, transferring the argument values
to the XLA device, executing the XLA program, and transferring back the
results. We‚Äôll cache the XLA HLO compilation so that for each <code class="docutils literal notranslate"><span class="pre">jit</span></code>ted
function it only needs to be performed once per argument shape and dtype
signature.</p>
<p>First, some utilities.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IDHashable</span><span class="p">:</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">Any</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">IDHashable</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we‚Äôll define the evaluation rule for <code class="docutils literal notranslate"><span class="pre">xla_call</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">from</span> <span class="nn">jax.extend.mlir</span> <span class="kn">import</span> <span class="n">ir</span>
<span class="kn">from</span> <span class="nn">jax.extend.mlir.dialects</span> <span class="kn">import</span> <span class="n">func</span>
<span class="kn">from</span> <span class="nn">jax.extend.mlir.dialects</span> <span class="kn">import</span> <span class="n">stablehlo</span> <span class="k">as</span> <span class="n">hlo</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">xla_bridge</span> <span class="k">as</span> <span class="n">xb</span>

<span class="k">class</span> <span class="nc">MlirContext</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">module</span><span class="p">:</span> <span class="n">ir</span><span class="o">.</span><span class="n">Module</span>
  <span class="n">symbol_table</span><span class="p">:</span> <span class="n">ir</span><span class="o">.</span><span class="n">SymbolTable</span>

<span class="k">def</span> <span class="nf">xla_call_impl</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="n">consts</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">num_consts</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="n">num_consts</span><span class="p">:]</span>
  <span class="n">hashable_consts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">IDHashable</span><span class="p">,</span> <span class="n">consts</span><span class="p">))</span>
  <span class="n">execute</span> <span class="o">=</span> <span class="n">xla_callable</span><span class="p">(</span><span class="n">IDHashable</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">),</span> <span class="n">hashable_consts</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">execute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_impl</span>

<span class="nd">@lru_cache</span>
<span class="k">def</span> <span class="nf">xla_callable</span><span class="p">(</span><span class="n">hashable_jaxpr</span><span class="p">:</span> <span class="n">IDHashable</span><span class="p">,</span>
                 <span class="n">hashable_consts</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">IDHashable</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
  <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span> <span class="o">=</span> <span class="n">hashable_jaxpr</span><span class="o">.</span><span class="n">val</span>
  <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="n">consts</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hashable_consts</span><span class="p">]</span>
  <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">consts</span><span class="p">):]]</span>

  <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">Context</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ir</span><span class="o">.</span><span class="n">Location</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="n">hlo</span><span class="o">.</span><span class="n">register_dialect</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">Module</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">MlirContext</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ir</span><span class="o">.</span><span class="n">SymbolTable</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">operation</span><span class="p">))</span>

    <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">InsertionPoint</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">body</span><span class="p">):</span>
      <span class="nd">@func</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">in_avals</span><span class="p">))</span>
      <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">jaxpr_subcomp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">_hlo_consts</span><span class="p">(</span><span class="n">consts</span><span class="p">)</span> <span class="o">+</span> <span class="n">params</span><span class="p">)</span>

  <span class="n">output</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
  <span class="n">c</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">operation</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
  <span class="n">backend</span> <span class="o">=</span> <span class="n">xb</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
  <span class="n">compiled</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">compile_and_load</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(),</span> <span class="n">backend</span><span class="o">.</span><span class="n">devices</span><span class="p">()[:</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">execute_compiled</span><span class="p">,</span> <span class="n">compiled</span><span class="p">,</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">_mlir_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ir</span><span class="o">.</span><span class="n">Type</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">signedinteger</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ir</span><span class="o">.</span><span class="n">IntegerType</span><span class="o">.</span><span class="n">get_signless</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ir</span><span class="o">.</span><span class="n">F32Type</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
  <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ir</span><span class="o">.</span><span class="n">F64Type</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;MLIR conversion not implemented for &quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">aval_to_ir_type</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ir</span><span class="o">.</span><span class="n">Type</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_mlir_dtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_hlo_const</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">:</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">hlo</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">ir</span><span class="o">.</span><span class="n">DenseElementsAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
      <span class="n">np</span><span class="o">.</span><span class="n">packbits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bitorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="n">ir</span><span class="o">.</span><span class="n">IntegerType</span><span class="o">.</span><span class="n">get_signless</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
      <span class="n">shape</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">hlo</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">ir</span><span class="o">.</span><span class="n">DenseElementsAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_hlo_consts</span><span class="p">(</span><span class="n">consts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">]:</span>
  <span class="n">unique_consts</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">cnst</span><span class="p">):</span> <span class="n">cnst</span> <span class="k">for</span> <span class="n">cnst</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">}</span>
  <span class="n">ir_consts</span> <span class="o">=</span> <span class="p">{</span><span class="n">id_</span><span class="p">:</span> <span class="n">_hlo_const</span><span class="p">(</span><span class="n">cnst</span><span class="p">)</span> <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">cnst</span> <span class="ow">in</span> <span class="n">unique_consts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ir_consts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">cnst</span><span class="p">)]</span> <span class="k">for</span> <span class="n">cnst</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The main action is in <code class="docutils literal notranslate"><span class="pre">xla_callable</span></code>, which compiles a jaxpr into an XLA HLO
program using <code class="docutils literal notranslate"><span class="pre">jaxpr_subcomp</span></code>, then returns a callable which executes the
compiled program:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jaxpr_subcomp</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">MlirContext</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">]:</span>
  <span class="n">env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">env</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">_hlo_const</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

  <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>
    <span class="n">in_vals</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">out_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">]</span>
    <span class="n">rule</span> <span class="o">=</span> <span class="n">hlo_translations</span><span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">in_vals</span><span class="p">),</span> <span class="n">in_vals</span>
    <span class="n">out_vals</span> <span class="o">=</span> <span class="n">rule</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">,</span> <span class="o">**</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_vals</span><span class="p">),</span> <span class="n">out_vals</span>
    <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">,</span> <span class="n">out_vals</span><span class="p">),</span> <span class="n">out_vals</span>
  <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">execute_compiled</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">input_bufs</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_handlers</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)](</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
  <span class="n">out_bufs</span> <span class="o">=</span> <span class="n">compiled</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">input_bufs</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">handle_result</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span><span class="p">,</span> <span class="n">buf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out_avals</span><span class="p">,</span> <span class="n">out_bufs</span><span class="p">)]</span>

<span class="n">default_input_handler</span> <span class="o">=</span> <span class="n">xb</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">buffer_from_pyval</span>
<span class="n">input_handlers</span> <span class="o">=</span> <span class="p">{</span><span class="n">ty</span><span class="p">:</span> <span class="n">default_input_handler</span> <span class="k">for</span> <span class="n">ty</span> <span class="ow">in</span>
                  <span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">]}</span>

<span class="k">def</span> <span class="nf">handle_result</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">aval</span>  <span class="c1"># Unused for now</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

<span class="n">hlo_translations</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that <code class="docutils literal notranslate"><span class="pre">jaxpr_subcomp</span></code> has the structure of a simple interpreter. That‚Äôs
a common pattern: the way we process jaxprs is usually with an interpreter.
And as with any interpreter, we need an interpretation rule for each
primitive:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">direct_translation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">in_vals</span><span class="p">)]</span>

<span class="n">hlo_translations</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">hlo</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>
<span class="n">hlo_translations</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">hlo</span><span class="o">.</span><span class="n">multiply</span><span class="p">)</span>
<span class="n">hlo_translations</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">hlo</span><span class="o">.</span><span class="n">negate</span><span class="p">)</span>
<span class="n">hlo_translations</span><span class="p">[</span><span class="n">sin_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">hlo</span><span class="o">.</span><span class="n">sine</span><span class="p">)</span>
<span class="n">hlo_translations</span><span class="p">[</span><span class="n">cos_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">hlo</span><span class="o">.</span><span class="n">cosine</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">compare_translation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">c</span><span class="p">,</span> <span class="n">out_avals</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">hlo</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="o">*</span><span class="n">in_vals</span><span class="p">,</span> <span class="n">hlo</span><span class="o">.</span><span class="n">ComparisonDirectionAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="p">))]</span>

<span class="n">hlo_translations</span><span class="p">[</span><span class="n">greater_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">compare_translation</span><span class="p">,</span> <span class="s2">&quot;GT&quot;</span><span class="p">)</span>
<span class="n">hlo_translations</span><span class="p">[</span><span class="n">less_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">compare_translation</span><span class="p">,</span> <span class="s2">&quot;LT&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">reduce_sum_translation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">c</span>
  <span class="p">(</span><span class="n">x_aval</span><span class="p">,),</span> <span class="p">(</span><span class="n">out_aval</span><span class="p">,),</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="o">=</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">in_vals</span>
  <span class="n">op</span> <span class="o">=</span> <span class="n">hlo</span><span class="o">.</span><span class="n">ReduceOp</span><span class="p">(</span>
    <span class="p">[</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">out_aval</span><span class="p">)],</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">_hlo_const</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))],</span>
    <span class="n">axis</span><span class="p">)</span>
  <span class="n">scalar_type</span> <span class="o">=</span> <span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">x_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
  <span class="n">reducer_region</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scalar_type</span><span class="p">,</span> <span class="n">scalar_type</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">InsertionPoint</span><span class="p">(</span><span class="n">reducer_region</span><span class="p">):</span>
    <span class="n">hlo</span><span class="o">.</span><span class="n">return_</span><span class="p">([</span><span class="n">hlo</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">reducer_region</span><span class="o">.</span><span class="n">arguments</span><span class="p">)])</span>
  <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">results</span>

<span class="n">hlo_translations</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_sum_translation</span>

<span class="k">def</span> <span class="nf">broadcast_translation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">c</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">out_aval</span><span class="p">,)</span> <span class="o">=</span> <span class="n">in_vals</span><span class="p">,</span> <span class="n">out_avals</span>
  <span class="n">dims_complement</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">hlo</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">out_aval</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">dims_complement</span><span class="p">)]</span>
<span class="n">hlo_translations</span><span class="p">[</span><span class="n">broadcast_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast_translation</span>
</pre></div>
</div>
</div>
</div>
<p>With that, we can now use <code class="docutils literal notranslate"><span class="pre">jit</span></code> to stage out, compile, and execute programs
with XLA!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;tracing!&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">)</span>  <span class="c1"># &#39;tracing!&#39; prints the first time</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tracing!
-0.09224219304455371
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span>  <span class="c1"># &#39;tracing!&#39; doesn&#39;t print, compilation cache hit!</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.21467624978306993
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">])))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="k">def</span> <span class="nf">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))[</span><span class="mi">1</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span>    <span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">))(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.2822400161197344
0.2822400161197344
</pre></div>
</div>
</div>
</div>
<p>Instead of implementing <code class="docutils literal notranslate"><span class="pre">jit</span></code> to first trace to a jaxpr and then to lower the
jaxpr to XLA HLO, it might appear that we could have skipped the jaxpr step
and just lowered to HLO while tracing. That is, perhaps we could have instead
implemented <code class="docutils literal notranslate"><span class="pre">jit</span></code> with a <code class="docutils literal notranslate"><span class="pre">Trace</span></code> and <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> that appended to the XLA HLO
graph incrementally on each primitive bind. That‚Äôs correct for now, but won‚Äôt
be possible when we introduce compiled SPMD computations because there we must
know the number of replicas needed before compiling the program.</p>
<p>We haven‚Äôt yet defined any transformation rules for <code class="docutils literal notranslate"><span class="pre">xla_call_p</span></code> other than
its evaluation rule. That is, we can‚Äôt yet do <code class="docutils literal notranslate"><span class="pre">vmap</span></code>-of-<code class="docutils literal notranslate"><span class="pre">jit</span></code> or
<code class="docutils literal notranslate"><span class="pre">jvp</span></code>-of-<code class="docutils literal notranslate"><span class="pre">jit</span></code> or even <code class="docutils literal notranslate"><span class="pre">jit</span></code>-of<code class="docutils literal notranslate"><span class="pre">-jit</span></code>. Instead <code class="docutils literal notranslate"><span class="pre">jit</span></code> has to be at the ‚Äútop
level.‚Äù Let‚Äôs fix that!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">xla_call_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Unused</span>
  <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span> <span class="o">=</span> <span class="n">jvp_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">new_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">primals</span><span class="p">,</span> <span class="o">*</span><span class="n">tangents</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">new_jaxpr</span><span class="p">,</span>
              <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_consts</span><span class="p">))</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
  <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">outs</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">outs</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_jvp_rule</span>

<span class="nd">@lru_cache</span>
<span class="k">def</span> <span class="nf">jvp_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="k">def</span> <span class="nf">jvp_traceable</span><span class="p">(</span><span class="o">*</span><span class="n">primals_and_tangents</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">primals_and_tangents</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span> <span class="o">=</span> <span class="n">primals_and_tangents</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">primals_and_tangents</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">jvp</span><span class="p">(</span><span class="n">jaxpr_as_fun</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">),</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">)</span>

  <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">]</span>
  <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">jvp_traceable</span><span class="p">,</span> <span class="o">*</span><span class="n">in_avals</span><span class="p">,</span> <span class="o">*</span><span class="n">in_avals</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">xla_call_vmap_rule</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Unused</span>
  <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span> <span class="o">=</span> <span class="n">vmap_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_in</span><span class="p">))</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">new_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">vals_in</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">new_jaxpr</span><span class="p">,</span>
              <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_consts</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">outs</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_vmap_rule</span>

<span class="nd">@lru_cache</span>
<span class="k">def</span> <span class="nf">vmap_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">bdims_in</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">BatchAxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
               <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="n">vmap_traceable</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">jaxpr_as_fun</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bdims_in</span><span class="p">))</span>
  <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">unmapped_aval</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">bdims_in</span><span class="p">)]</span>
  <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">vmap_traceable</span><span class="p">,</span> <span class="o">*</span><span class="n">in_avals</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span>

<span class="k">def</span> <span class="nf">unmapped_aval</span><span class="p">(</span><span class="n">axis_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">batch_dim</span><span class="p">:</span> <span class="n">BatchAxis</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">batch_dim</span> <span class="ow">is</span> <span class="n">not_mapped</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">aval</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">batch_dim</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">xla_call_abstract_eval_rule</span><span class="p">(</span><span class="o">*</span><span class="n">in_types</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Unused</span>
  <span class="n">jaxpr_type</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span> <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr_type</span><span class="o">.</span><span class="n">in_types</span><span class="p">,</span> <span class="n">in_types</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">return</span> <span class="n">jaxpr_type</span><span class="o">.</span><span class="n">out_types</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_abstract_eval_rule</span>

<span class="k">def</span> <span class="nf">xla_call_translation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">out_avals</span>
  <span class="c1"># Calling jaxpr_subcomp directly would inline. We generate a Call HLO instead.</span>
  <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">InsertionPoint</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">body</span><span class="p">):</span>
    <span class="nd">@func</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">in_avals</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">inner_xla_call</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">jaxpr_subcomp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">inner_xla_call</span><span class="o">.</span><span class="n">func_op</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">CallOp</span><span class="p">(</span><span class="n">inner_xla_call</span><span class="o">.</span><span class="n">func_op</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>
<span class="n">hlo_translations</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_translation</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;tracing!&#39;</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="n">x</span><span class="p">,</span> <span class="n">xdot</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span>
<span class="n">y</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">xdot</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tracing!
2.7177599838802657
2.979984993200891
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">xdot</span><span class="p">,))</span>  <span class="c1"># &#39;tracing!&#39; not printed</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ys</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 0.         -0.68294197  0.18140515]
</pre></div>
</div>
</div>
</div>
<p>One piece missing is device memory persistence for arrays. That is, we‚Äôve
defined <code class="docutils literal notranslate"><span class="pre">handle_result</span></code> to transfer results back to CPU memory as NumPy
arrays, but it‚Äôs often preferable to avoid transferring results just to
transfer them back for the next operation. We can do that by introducing an
<code class="docutils literal notranslate"><span class="pre">Array</span></code> class, which can wrap XLA buffers and otherwise duck-type
<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>s:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handle_result</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>  <span class="c1"># noqa: F811</span>
  <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Array</span><span class="p">:</span>
  <span class="n">buf</span><span class="p">:</span> <span class="n">Any</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span>

  <span class="n">dtype</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">ndim</span>  <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buf</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buf</span><span class="p">))</span>
  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>   <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buf</span><span class="p">))</span>

  <span class="n">_neg</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span>
  <span class="n">_add</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
  <span class="n">_radd</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
  <span class="n">_mul</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">mul</span><span class="p">)</span>
  <span class="n">_rmul</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">mul</span><span class="p">)</span>
  <span class="n">_gt</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">greater</span><span class="p">)</span>
  <span class="n">_lt</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">less</span><span class="p">)</span>
<span class="n">input_handlers</span><span class="p">[</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">buf</span>

<span class="n">jax_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Array</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="n">x</span><span class="p">,</span> <span class="n">xdot</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span>
<span class="n">y</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">xdot</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.7177599838802657
2.979984993200891
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pprint_xla_call</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">var_str</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">))</span>
  <span class="n">params_without_jaxpr</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;jaxpr&#39;</span><span class="p">}</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">pp_params</span><span class="p">(</span><span class="n">params_without_jaxpr</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
         <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Var</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">vcat</span><span class="p">([</span><span class="n">lhs</span> <span class="o">&gt;&gt;</span> <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; = &#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rhs</span><span class="p">,</span>
               <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;jaxpr&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">pp_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pprint_xla_call</span>
</pre></div>
</div>
</div>
</details>
</div>
</section>
</section>
<section id="part-4-linearize-and-vjp-and-grad">
<h2>Part 4: <code class="docutils literal notranslate"><span class="pre">linearize</span></code> and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> (and <code class="docutils literal notranslate"><span class="pre">grad</span></code>!)<a class="headerlink" href="#part-4-linearize-and-vjp-and-grad" title="Link to this heading">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">linearize</span></code> and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> autodiff functions are built on <code class="docutils literal notranslate"><span class="pre">jvp</span></code>, but involve
jaxprs as well. That‚Äôs because both involve staging out, or delaying,
computation.</p>
<section id="linearize">
<h3><code class="docutils literal notranslate"><span class="pre">linearize</span></code><a class="headerlink" href="#linearize" title="Link to this heading">#</a></h3>
<p>In the case of <code class="docutils literal notranslate"><span class="pre">linearize</span></code>, we want to stage out the linear part of a <code class="docutils literal notranslate"><span class="pre">jvp</span></code>
computation. That is, in terms of
<a class="reference external" href="https://wiki.haskell.org/Type_signature">Haskell-like type signatures</a>,
if we have <code class="docutils literal notranslate"><span class="pre">jvp</span> <span class="pre">:</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">(a,</span> <span class="pre">T</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">(b,</span> <span class="pre">T</span> <span class="pre">b)</span></code>,
then we write <code class="docutils literal notranslate"><span class="pre">linearize</span> <span class="pre">:</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(b,</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">-o</span> <span class="pre">T</span> <span class="pre">b)</span></code>, using <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">a</span></code> to
mean ‚Äúthe tangent type of <code class="docutils literal notranslate"><span class="pre">a</span></code>‚Äù and using the ‚Äúlollipop‚Äù <code class="docutils literal notranslate"><span class="pre">-o</span></code> rather than the
arrow <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> to indicate a <em>linear</em> function. We define the semantics of
<code class="docutils literal notranslate"><span class="pre">linearize</span></code> in terms of <code class="docutils literal notranslate"><span class="pre">jvp</span></code> too:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">y_dot</span> <span class="o">=</span> <span class="n">f_lin</span><span class="p">(</span><span class="n">x_dot</span><span class="p">)</span>
</pre></div>
</div>
<p>gives the same result for <code class="docutils literal notranslate"><span class="pre">(y,</span> <span class="pre">y_dot)</span></code> as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">,</span> <span class="n">y_dot</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,))</span>
</pre></div>
</div>
<p>where the application of <code class="docutils literal notranslate"><span class="pre">f_lin</span></code> does not redo any of the linearization work.
We‚Äôll represent the delayed linear part <code class="docutils literal notranslate"><span class="pre">f_lin</span> <span class="pre">:</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">-o</span> <span class="pre">T</span> <span class="pre">b</span></code> as a jaxpr.</p>
<p>Tangentially, now that we have linear arrows <code class="docutils literal notranslate"><span class="pre">-o</span></code>, we can provide a slightly
more informative type for <code class="docutils literal notranslate"><span class="pre">jvp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jvp</span> <span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">UnrestrictedUse</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">a</span><span class="p">)</span> <span class="o">-</span><span class="n">o</span> <span class="p">(</span><span class="n">UnrestrictedUse</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we‚Äôre writing <code class="docutils literal notranslate"><span class="pre">UnrestrictedUse</span></code> just to indicate that we have a special
pair where the first element can be used in an unrestricted (nonlinear) way.
In conjunction with the linear arrow, this notation is just meant to express
that the function <code class="docutils literal notranslate"><span class="pre">jvp</span> <span class="pre">f</span></code> uses its first input in a nonlinear way but its
second input in a linear way, producing a corresponding nonlinear output
(which can be used in a nonlinear way) paired with a linear output. This more
refined type signature encodes the data dependencies in <code class="docutils literal notranslate"><span class="pre">jvp</span> <span class="pre">f</span></code>, which are
useful for partial evaluation.</p>
<p>To build the <code class="docutils literal notranslate"><span class="pre">f_lin</span></code> jaxpr from a JVP, we need to perform partial evaluation:
we evaluate all the primal values as we trace, but stage the tangent
computations into a jaxpr. This is our second way to build jaxprs. But where
<code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code> and its underlying <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code>/<code class="docutils literal notranslate"><span class="pre">JaxprTracer</span></code> interpreters aim
to stage out every primitive bind, this second approach stages out only those
primitive binds with a data dependence on tangent inputs.</p>
<p>First, some utilities:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">split_half</span><span class="p">(</span><span class="n">lst</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="k">assert</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="n">split_list</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">merge_lists</span><span class="p">(</span><span class="n">which</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">l1</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">l2</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
  <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">l1</span><span class="p">),</span> <span class="nb">iter</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="nb">next</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">which</span><span class="p">]</span>
  <span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">next</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we‚Äôll write <code class="docutils literal notranslate"><span class="pre">linearize</span></code> by combining <code class="docutils literal notranslate"><span class="pre">jvp</span></code> together with a general
partial evaluation transformation, to be added next:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">linearize_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in</span><span class="p">):</span>
  <span class="n">pvals_in</span> <span class="o">=</span> <span class="p">([</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">known</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">primals_in</span><span class="p">]</span> <span class="o">+</span>
              <span class="p">[</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">vspace</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">primals_in</span><span class="p">])</span>
  <span class="k">def</span> <span class="nf">f_jvp</span><span class="p">(</span><span class="o">*</span><span class="n">primals_tangents_in</span><span class="p">):</span>
    <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">split_half</span><span class="p">(</span><span class="n">primals_tangents_in</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">primals_out</span><span class="p">,</span> <span class="o">*</span><span class="n">tangents_out</span><span class="p">]</span>
  <span class="n">jaxpr</span><span class="p">,</span> <span class="n">pvals_out</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">partial_eval_flat</span><span class="p">(</span><span class="n">f_jvp</span><span class="p">,</span> <span class="n">pvals_in</span><span class="p">)</span>
  <span class="n">primal_pvals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_half</span><span class="p">(</span><span class="n">pvals_out</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">primal_pvals</span><span class="p">)</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">primal_pvals</span><span class="p">]</span>
  <span class="n">f_lin</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">tangents</span><span class="p">:</span> <span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="p">[</span><span class="o">*</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">tangents</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">f_lin</span>

<span class="k">def</span> <span class="nf">linearize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in</span><span class="p">):</span>
  <span class="n">primals_in_flat</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">primals_in</span><span class="p">)</span>
  <span class="n">f</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>
  <span class="n">primals_out_flat</span><span class="p">,</span> <span class="n">f_lin_flat</span> <span class="o">=</span> <span class="n">linearize_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in_flat</span><span class="p">)</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">primals_out_flat</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">f_lin</span><span class="p">(</span><span class="o">*</span><span class="n">tangents_in</span><span class="p">):</span>
    <span class="n">tangents_in_flat</span><span class="p">,</span> <span class="n">in_tree2</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">tangents_in</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">in_tree</span> <span class="o">!=</span> <span class="n">in_tree2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="n">tangents_out_flat</span> <span class="o">=</span> <span class="n">f_lin_flat</span><span class="p">(</span><span class="o">*</span><span class="n">tangents_in_flat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">tangents_out_flat</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">f_lin</span>

<span class="k">def</span> <span class="nf">vspace</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>  <span class="c1"># TODO handle integers?</span>
</pre></div>
</div>
</div>
</div>
<p>Now we turn to the general partial evaluation transformation. The goal is to
accept a Python callable and a list of inputs, some known and some unknown,
and to produce (1) all the outputs which can be computed from the known
inputs, together with (2) a jaxpr representing the part of the Python
callable‚Äôs computation which can only be performed after the remaining inputs
are known.</p>
<p>This transformation is tricky to summarize in a type signature. If we
assume the input function‚Äôs type signature is <code class="docutils literal notranslate"><span class="pre">(a1,</span> <span class="pre">a2)</span> <span class="pre">-&gt;</span> <span class="pre">(b1,</span> <span class="pre">b2)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">a1</span></code> and <code class="docutils literal notranslate"><span class="pre">a2</span></code> represent the known and unknown inputs, respectively, and where
<code class="docutils literal notranslate"><span class="pre">b1</span></code> only has a data dependency on <code class="docutils literal notranslate"><span class="pre">a1</span></code> while <code class="docutils literal notranslate"><span class="pre">b2</span></code> has some data dependency on
<code class="docutils literal notranslate"><span class="pre">a2</span></code>, then we might write</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">partial_eval</span> <span class="p">:</span> <span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">a1</span> <span class="o">-&gt;</span> <span class="n">exists</span> <span class="n">r</span><span class="o">.</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b2</span><span class="p">)</span>
</pre></div>
</div>
<p>In words, given values for the inputs of type <code class="docutils literal notranslate"><span class="pre">a1</span></code>, <code class="docutils literal notranslate"><span class="pre">partial_eval</span></code> produces
the outputs of type <code class="docutils literal notranslate"><span class="pre">b1</span></code> along with ‚Äúresidual‚Äù values of
existentially-quantified type <code class="docutils literal notranslate"><span class="pre">r</span></code> representing the intermediates required to
complete the computation in the second stage. It also produces a function of
type <code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">a2)</span> <span class="pre">-&gt;</span> <span class="pre">b2</span></code> which accepts the residual values as well as the
remaining inputs and produces the remaining outputs.</p>
<p>We like to think of partial evaluation as ‚Äúunzipping‚Äù one computation into
two. For example, consider this jaxpr:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span> <span class="n">b</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">sin</span> <span class="n">a</span>
      <span class="n">c</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">neg</span> <span class="n">b</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="n">c</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>A jaxpr for the JVP would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="n">b</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span> <span class="n">c</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">sin</span> <span class="n">a</span>
      <span class="n">d</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">cos</span> <span class="n">a</span>
      <span class="n">e</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">d</span> <span class="n">b</span>
      <span class="n">f</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">neg</span> <span class="n">c</span>
      <span class="n">g</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">neg</span> <span class="n">e</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>If we imagine applying partial evaluation to this jaxpr with the first input
known and the second unknown, we end up ‚Äòunzipping‚Äô the JVP jaxpr into primal
and tangent jaxprs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span> <span class="n">c</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">sin</span> <span class="n">a</span>
      <span class="n">d</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">cos</span> <span class="n">a</span>
      <span class="n">f</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">neg</span> <span class="n">c</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="n">d</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="n">b</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span> <span class="n">e</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">d</span> <span class="n">b</span>
      <span class="n">g</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">neg</span> <span class="n">e</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="n">g</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>This second jaxpr represents the linear computation that we want from
<code class="docutils literal notranslate"><span class="pre">linearize</span></code>.</p>
<p>However, unlike in this jaxpr example, we want the computation on known values
to occur while evaluating the input Python callable. That is, rather than
forming a jaxpr for the entire function <code class="docutils literal notranslate"><span class="pre">(a1,</span> <span class="pre">a2)</span> <span class="pre">-&gt;</span> <span class="pre">(b1,</span> <span class="pre">b2)</span></code>, staging all
operations out of Python first before sorting out what can be evaluated now
and what must be delayed, we want only to form a jaxpr for those operations
that <em>must</em> be delayed due to a dependence on unknown inputs. In the context
of automatic differentiation, this is the feature that ultimately enables us
to handle functions like <code class="docutils literal notranslate"><span class="pre">grad(lambda</span> <span class="pre">x:</span> <span class="pre">x**2</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">else</span> <span class="pre">0.)</span></code>. Python
control flow works because partial evaluation keeps the primal computation in
Python. As a consequence, our <code class="docutils literal notranslate"><span class="pre">Trace</span></code> and <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> subclasses must on the fly
sort out what can be evaluated and what must be staged out into a jaxpr.</p>
<p>First, we start with a <code class="docutils literal notranslate"><span class="pre">PartialVal</span></code> class, which represents a value that can
be either known or unknown:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PartialVal</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>
  <span class="n">const</span><span class="p">:</span> <span class="n">Any</span> <span class="o">|</span> <span class="kc">None</span>

  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">known</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">PartialVal</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">val</span><span class="p">)</span>

  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">unknown</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">PartialVal</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

  <span class="n">is_known</span>   <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">is_unknown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="ow">is</span>     <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Partial evaluation will take a list of <code class="docutils literal notranslate"><span class="pre">PartialVal</span></code>s representing inputs, and
return a list of <code class="docutils literal notranslate"><span class="pre">PartialVal</span></code> outputs along with a jaxpr representing the
delayed computation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">partial_eval_flat</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">pvals_in</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">PartialVal</span><span class="p">]</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">PartialVal</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">PartialEvalTrace</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">PartialEvalTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">new_arg</span><span class="p">(</span><span class="n">pval</span><span class="p">)</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">pvals_in</span><span class="p">]</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
    <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
    <span class="n">pvals_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span><span class="p">]</span>
    <span class="n">unk_tracers_in</span>  <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_in</span>  <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">]</span>
    <span class="n">unk_tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">]</span>
    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">tracers_to_jaxpr</span><span class="p">(</span><span class="n">unk_tracers_in</span><span class="p">,</span> <span class="n">unk_tracers_out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">pvals_out</span><span class="p">,</span> <span class="n">consts</span>
</pre></div>
</div>
</div>
</div>
<p>Next we need to implement <code class="docutils literal notranslate"><span class="pre">PartialEvalTrace</span></code> and its <code class="docutils literal notranslate"><span class="pre">PartialEvalTracer</span></code>. This
interpreter will build a jaxpr on the fly while tracking data dependencies. To
do so, it builds a bipartite directed acyclic graph (DAG) between
<code class="docutils literal notranslate"><span class="pre">PartialEvalTracer</span></code> nodes, representing staged-out values, and <code class="docutils literal notranslate"><span class="pre">JaxprRecipe</span></code>
nodes, representing formulas for how to compute some values from others. One
kind of recipe is a <code class="docutils literal notranslate"><span class="pre">JaxprEqnRecipe</span></code>, corresponding to a <code class="docutils literal notranslate"><span class="pre">JaxprEqn</span></code>‚Äôs
primitive application, but we also have recipe types for constants and lambda
binders:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">weakref</span> <span class="kn">import</span> <span class="n">ref</span><span class="p">,</span> <span class="n">ReferenceType</span>

<span class="k">class</span> <span class="nc">LambdaBindingRecipe</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="k">pass</span>

<span class="k">class</span> <span class="nc">ConstRecipe</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">Any</span>

<span class="k">class</span> <span class="nc">JaxprEqnRecipe</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">prim</span><span class="p">:</span> <span class="n">Primitive</span>
  <span class="n">tracers_in</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s1">&#39;PartialEvalTracer&#39;</span><span class="p">]</span>
  <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
  <span class="n">avals_out</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]</span>
  <span class="n">tracer_refs_out</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s1">&#39;ReferenceType[PartialEvalTracer]&#39;</span><span class="p">]</span>

<span class="n">JaxprRecipe</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">LambdaBindingRecipe</span><span class="p">,</span> <span class="n">ConstRecipe</span><span class="p">,</span> <span class="n">JaxprEqnRecipe</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PartialEvalTracer</span><span class="p">(</span><span class="n">Tracer</span><span class="p">):</span>
  <span class="n">pval</span><span class="p">:</span> <span class="n">PartialVal</span>
  <span class="n">recipe</span><span class="p">:</span> <span class="n">JaxprRecipe</span> <span class="o">|</span> <span class="kc">None</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">recipe</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pval</span> <span class="o">=</span> <span class="n">pval</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="n">recipe</span>

  <span class="n">aval</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">full_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">full_lower</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PartialEvalTrace</span></code> contains the logic for constructing the graph of
<code class="docutils literal notranslate"><span class="pre">JaxprRecipe</span></code>s and <code class="docutils literal notranslate"><span class="pre">PartialEvalTracer</span></code>s. Each argument corresponds to a
<code class="docutils literal notranslate"><span class="pre">LambdaBindingRecipe</span></code> leaf node, and each constant is a <code class="docutils literal notranslate"><span class="pre">ConstRecipe</span></code> leaf
node holding a reference to the constant. All other tracers and recipes come
from <code class="docutils literal notranslate"><span class="pre">process_primitive</span></code>, which forms tracers with <code class="docutils literal notranslate"><span class="pre">JaxprEqnRecipe</span></code>s.</p>
<p>For most primitives, the <code class="docutils literal notranslate"><span class="pre">process_primitive</span></code> logic is straightforward: if all
inputs are known then we can bind the primitive on the known values
(evaluating it in Python) and avoid forming tracers corresponding to the
output. If instead any input is unknown then we instead stage out into a
<code class="docutils literal notranslate"><span class="pre">JaxprEqnRecipe</span></code> representing the primitive application. To build the tracers
representing unknown outputs, we need avals, which we get from the abstract
eval rules. (Notice that tracers reference <code class="docutils literal notranslate"><span class="pre">JaxprEqnRecipe</span></code>s, and
<code class="docutils literal notranslate"><span class="pre">JaxprEqnRecipe</span></code>s reference tracers; we avoid circular garbage by using
<code class="docutils literal notranslate"><span class="pre">weakref</span></code>s.)</p>
<p>That <code class="docutils literal notranslate"><span class="pre">process_primitive</span></code> logic applies to most primitives, but <code class="docutils literal notranslate"><span class="pre">xla_call_p</span></code>
requires recursive treatment. So we special-case its rule in a
<code class="docutils literal notranslate"><span class="pre">partial_eval_rules</span></code> dict.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PartialEvalTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">new_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pval</span><span class="p">:</span> <span class="n">PartialVal</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">PartialEvalTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">LambdaBindingRecipe</span><span class="p">())</span>

  <span class="k">def</span> <span class="nf">lift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PartialEvalTracer</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">PartialEvalTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PartialVal</span><span class="o">.</span><span class="n">known</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">lift</span>

  <span class="k">def</span> <span class="nf">instantiate_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">:</span> <span class="n">PartialEvalTracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PartialEvalTracer</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">tracer</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">tracer</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">pval</span> <span class="o">=</span> <span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">aval</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">PartialEvalTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">ConstRecipe</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">bind</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">full_lower</span><span class="p">,</span> <span class="n">tracers</span><span class="p">),</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">rule</span> <span class="o">=</span> <span class="n">partial_eval_rules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">primitive</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rule</span><span class="p">:</span> <span class="k">return</span> <span class="n">rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>
    <span class="n">avals_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_in</span><span class="p">]</span>
    <span class="n">avals_out</span> <span class="o">=</span> <span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">](</span><span class="o">*</span><span class="n">avals_in</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">aval</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">avals_out</span><span class="p">]</span>
    <span class="n">eqn</span> <span class="o">=</span> <span class="n">JaxprEqnRecipe</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">tracers_in</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">avals_out</span><span class="p">,</span>
                         <span class="nb">map</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">tracers_out</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="n">eqn</span>
    <span class="k">return</span> <span class="n">tracers_out</span>

<span class="n">partial_eval_rules</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we can build graph representations of jaxprs with <code class="docutils literal notranslate"><span class="pre">PartialEvalTrace</span></code>,
we need a mechanism to convert the graph representation to a standard jaxpr.
The jaxpr corresponds to a topological sort of the graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tracers_to_jaxpr</span><span class="p">(</span><span class="n">tracers_in</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">],</span>
                     <span class="n">tracers_out</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">]):</span>
  <span class="n">tracer_to_var</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">):</span> <span class="n">Var</span><span class="p">(</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">aval</span><span class="p">))</span>
                                   <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_in</span><span class="p">}</span>
  <span class="n">constvar_to_val</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">constid_to_var</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">processed_eqns</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="n">eqns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">toposort</span><span class="p">(</span><span class="n">tracers_out</span><span class="p">,</span> <span class="n">tracer_parents</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">,</span> <span class="n">LambdaBindingRecipe</span><span class="p">):</span>
      <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">tracers_in</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">,</span> <span class="n">ConstRecipe</span><span class="p">):</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="o">.</span><span class="n">val</span>
      <span class="n">var</span> <span class="o">=</span> <span class="n">constid_to_var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
      <span class="k">if</span> <span class="n">var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aval</span> <span class="o">=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">constid_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
        <span class="n">constvar_to_val</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
      <span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="o">=</span> <span class="n">var</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">,</span> <span class="n">JaxprEqnRecipe</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_eqns</span><span class="p">:</span>
        <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recipe_to_eqn</span><span class="p">(</span><span class="n">tracer_to_var</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">))</span>
        <span class="n">processed_eqns</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">)</span>

  <span class="n">constvars</span><span class="p">,</span> <span class="n">constvals</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">(</span><span class="n">constvar_to_val</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
  <span class="n">in_binders</span> <span class="o">=</span> <span class="n">constvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_in</span><span class="p">]</span>
  <span class="n">out_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span><span class="p">]</span>
  <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">eqns</span><span class="p">,</span> <span class="n">out_vars</span><span class="p">)</span>
  <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">constvals</span>

<span class="k">def</span> <span class="nf">recipe_to_eqn</span><span class="p">(</span><span class="n">tracer_to_var</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Var</span><span class="p">],</span> <span class="n">recipe</span><span class="p">:</span> <span class="n">JaxprEqnRecipe</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprEqn</span><span class="p">:</span>
  <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">recipe</span><span class="o">.</span><span class="n">tracers_in</span><span class="p">]</span>
  <span class="n">out_binders</span> <span class="o">=</span> <span class="p">[</span><span class="n">Var</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">recipe</span><span class="o">.</span><span class="n">avals_out</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">t_ref</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">recipe</span><span class="o">.</span><span class="n">tracer_refs_out</span><span class="p">,</span> <span class="n">out_binders</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t_ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t_ref</span><span class="p">())]</span> <span class="o">=</span> <span class="n">var</span>
  <span class="k">return</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">recipe</span><span class="o">.</span><span class="n">prim</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">recipe</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">out_binders</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">tracer_parents</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">PartialEvalTracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">]:</span>
  <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="o">.</span><span class="n">tracers_in</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">,</span> <span class="n">JaxprEqnRecipe</span><span class="p">)</span> <span class="k">else</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">toposort</span><span class="p">(</span><span class="n">out_nodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">parents</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">out_nodes</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
  <span class="n">out_nodes</span> <span class="o">=</span> <span class="n">remove_duplicates</span><span class="p">(</span><span class="n">out_nodes</span><span class="p">)</span>

  <span class="n">child_counts</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out_nodes</span><span class="p">)</span>
  <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="ow">in</span> <span class="n">child_counts</span><span class="p">:</span>
      <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">parents</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">out_nodes</span><span class="p">:</span>
    <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span>

  <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">childless_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">out_nodes</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)]]</span>
  <span class="k">while</span> <span class="n">childless_nodes</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">childless_nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">sorted_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">parent</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">childless_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">parent</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span>

  <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="n">sorted_nodes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">check_toposort</span><span class="p">(</span><span class="n">sorted_nodes</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">sorted_nodes</span>

<span class="k">def</span> <span class="nf">remove_duplicates</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
  <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>

<span class="k">def</span> <span class="nf">check_toposort</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">parents</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]):</span>
  <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>Now we can linearize!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">,</span> <span class="n">sin_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="mf">3.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sin_lin</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.1411200080598672 0.1411200080598672
-0.9899924966004454 -0.9899924966004454
</pre></div>
</div>
</div>
</div>
<p>To handle <code class="docutils literal notranslate"><span class="pre">linearize</span></code>-of-<code class="docutils literal notranslate"><span class="pre">jit</span></code>, we still need to write a partial evaluation
rule for <code class="docutils literal notranslate"><span class="pre">xla_call_p</span></code>. Other than tracer bookkeeping, the main task is to
perform partial evaluation of a jaxpr, ‚Äòunzipping‚Äô it into two jaxprs.</p>
<p>There are actually two rules to write: one for trace-time partial evaluation,
which we‚Äôll call <code class="docutils literal notranslate"><span class="pre">xla_call_partial_eval</span></code>, and one for partial evaluation of
jaxprs, which we‚Äôll call <code class="docutils literal notranslate"><span class="pre">xla_call_peval_eqn</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">xla_call_partial_eval</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Unused</span>
  <span class="n">in_unknowns</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>
  <span class="n">jaxpr1</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">,</span> <span class="n">out_unknowns</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">in_unknowns</span><span class="p">)</span>
  <span class="n">known_tracers</span><span class="p">,</span> <span class="n">unknown_tracers</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">in_unknowns</span><span class="p">,</span> <span class="n">tracers</span><span class="p">)</span>
  <span class="n">known_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">known_tracers</span><span class="p">]</span>
  <span class="n">outs1_res</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">known_vals</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr1</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">outs1</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">outs1_res</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_res</span><span class="p">)</span>
  <span class="n">res_tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">(</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
  <span class="n">outs2</span> <span class="o">=</span> <span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">]</span>
  <span class="n">eqn</span> <span class="o">=</span> <span class="n">JaxprEqnRecipe</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="n">res_tracers</span> <span class="o">+</span> <span class="n">unknown_tracers</span><span class="p">,</span>
                       <span class="nb">dict</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr2</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                       <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">],</span> <span class="nb">map</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">outs2</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">outs2</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="n">eqn</span>
  <span class="k">return</span> <span class="n">merge_lists</span><span class="p">(</span><span class="n">out_unknowns</span><span class="p">,</span> <span class="n">outs1</span><span class="p">,</span> <span class="n">outs2</span><span class="p">)</span>
<span class="n">partial_eval_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_partial_eval</span>

<span class="k">def</span> <span class="nf">partial_eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">in_unknowns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
                       <span class="n">instantiate</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
  <span class="n">env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">residuals</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="ow">and</span> <span class="n">env</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">unk</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">unk</span>

  <span class="k">def</span> <span class="nf">new_res</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atom</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span><span class="p">:</span> <span class="n">residuals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>

  <span class="n">eqns1</span><span class="p">,</span> <span class="n">eqns2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
  <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">in_unknowns</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="n">unks_in</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">rule</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr_rules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rule</span><span class="p">:</span>
      <span class="n">eqn1</span><span class="p">,</span> <span class="n">eqn2</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">rule</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">eqn</span><span class="p">)</span>
      <span class="n">eqns1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqn1</span><span class="p">);</span> <span class="n">eqns2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqn2</span><span class="p">);</span> <span class="n">residuals</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
      <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">unks_in</span><span class="p">):</span>
      <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">if</span> <span class="n">unk</span> <span class="k">else</span> <span class="n">new_res</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">unk</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)]</span>
      <span class="n">eqns2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">JaxprEqn</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">))</span>
      <span class="nb">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">eqns1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqn</span><span class="p">)</span>
      <span class="nb">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
  <span class="n">out_unknowns</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">instantiate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">uk</span><span class="p">,</span> <span class="n">inst</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">,</span> <span class="n">out_unknowns</span><span class="p">,</span> <span class="n">instantiate</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">inst</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">uk</span><span class="p">:</span> <span class="n">new_res</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">out_unknowns</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">out_unknowns</span><span class="p">,</span> <span class="n">instantiate</span><span class="p">)</span>

  <span class="n">residuals</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">residuals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">residuals</span><span class="p">),</span> <span class="n">residuals</span>

  <span class="n">ins1</span><span class="p">,</span> <span class="n">ins2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">in_unknowns</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">)</span>
  <span class="n">outs1</span><span class="p">,</span> <span class="n">outs2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">out_unknowns</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>

  <span class="n">jaxpr1</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">ins1</span><span class="p">,</span> <span class="n">eqns1</span><span class="p">,</span> <span class="n">outs1</span> <span class="o">+</span> <span class="n">residuals</span><span class="p">)</span>
  <span class="n">jaxpr2</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">residuals</span> <span class="o">+</span> <span class="n">ins2</span><span class="p">,</span> <span class="n">eqns2</span><span class="p">,</span> <span class="n">outs2</span><span class="p">)</span>
  <span class="n">typecheck_partial_eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">in_unknowns</span><span class="p">,</span> <span class="n">out_unknowns</span><span class="p">,</span> <span class="n">jaxpr1</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">jaxpr1</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">,</span> <span class="n">out_unknowns</span><span class="p">,</span> <span class="n">num_res</span>

<span class="k">def</span> <span class="nf">typecheck_partial_eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">unks_in</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">jaxpr1</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">):</span>
  <span class="n">jaxprty</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>    <span class="c1"># (a1,  a2) -&gt; (b1, b2 )</span>
  <span class="n">jaxpr1ty</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr1</span><span class="p">)</span>  <span class="c1">#  a1       -&gt; (b1, res)</span>
  <span class="n">jaxpr2ty</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr2</span><span class="p">)</span>  <span class="c1"># (res, a2) -&gt; b2</span>

  <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">jaxprty</span><span class="o">.</span><span class="n">in_types</span><span class="p">)</span>
  <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_out</span><span class="p">,</span> <span class="n">jaxprty</span><span class="o">.</span><span class="n">out_types</span><span class="p">)</span>
  <span class="n">b1_</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr1ty</span><span class="o">.</span><span class="n">out_types</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">))</span>
  <span class="n">res_</span><span class="p">,</span> <span class="n">a2_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr2ty</span><span class="o">.</span><span class="n">in_types</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
  <span class="n">b2_</span> <span class="o">=</span> <span class="n">jaxpr2ty</span><span class="o">.</span><span class="n">out_types</span>

  <span class="k">if</span> <span class="n">jaxpr1ty</span><span class="o">.</span><span class="n">in_types</span> <span class="o">!=</span> <span class="n">a1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">jaxpr2ty</span><span class="o">.</span><span class="n">out_types</span> <span class="o">!=</span> <span class="n">b2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b1_</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">res</span> <span class="o">!=</span> <span class="n">res_</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">a2</span> <span class="o">!=</span> <span class="n">a2_</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">b2</span> <span class="o">!=</span> <span class="n">b2_</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>

<span class="n">partial_eval_jaxpr_rules</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">xla_call_peval_eqn</span><span class="p">(</span><span class="n">unks_in</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">,</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">JaxprEqn</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Var</span><span class="p">]]:</span>
  <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;jaxpr&#39;</span><span class="p">]</span>
  <span class="n">jaxpr1</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">unks_in</span><span class="p">)</span>
  <span class="n">ins1</span><span class="p">,</span> <span class="n">ins2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
  <span class="n">out_binders1</span><span class="p">,</span> <span class="n">out_binders2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_out</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
  <span class="n">residuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">Var</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">in_binders</span><span class="p">[:</span><span class="n">num_res</span><span class="p">]]</span>
  <span class="n">eqn1</span> <span class="o">=</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="n">ins1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr1</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                  <span class="n">out_binders1</span> <span class="o">+</span> <span class="n">residuals</span><span class="p">)</span>
  <span class="n">eqn2</span> <span class="o">=</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="n">residuals</span> <span class="o">+</span> <span class="n">ins2</span><span class="p">,</span>
                  <span class="nb">dict</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr2</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">out_binders2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">eqn1</span><span class="p">,</span> <span class="n">eqn2</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">residuals</span>
<span class="n">partial_eval_jaxpr_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_peval_eqn</span>
</pre></div>
</div>
</div>
</div>
<p>With that, we can compose <code class="docutils literal notranslate"><span class="pre">linearize</span></code> and <code class="docutils literal notranslate"><span class="pre">jit</span></code> however we like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="n">y</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">3.</span><span class="p">)</span>
<span class="n">y_dot</span> <span class="o">=</span> <span class="n">f_lin</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_dot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.7177599838802657 2.979984993200891
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">y</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">3.</span><span class="p">)</span>
<span class="n">y_dot</span> <span class="o">=</span> <span class="n">f_lin</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_dot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.7077524804807109 -2.121105001260758
</pre></div>
</div>
</div>
</div>
</section>
<section id="vjp-and-grad">
<h3><code class="docutils literal notranslate"><span class="pre">vjp</span></code> and <code class="docutils literal notranslate"><span class="pre">grad</span></code><a class="headerlink" href="#vjp-and-grad" title="Link to this heading">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">vjp</span></code> transformation works a lot like linearize. Its type signature is
analogous:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">linearize</span> <span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">a</span> <span class="o">-</span><span class="n">o</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span>
<span class="n">vjp</span>       <span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span> <span class="o">-</span><span class="n">o</span> <span class="n">T</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The only difference is that we transpose the linear part of the computation
before returning it, so that it goes from type <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">a</span> <span class="pre">-o</span> <span class="pre">T</span> <span class="pre">b</span></code> to type <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">b</span> <span class="pre">-o</span> <span class="pre">T</span> <span class="pre">a</span></code>. That is, we‚Äôll implement <code class="docutils literal notranslate"><span class="pre">vjp</span></code> as, essentially,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vjp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">y</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">f_vjp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y_bar</span><span class="p">:</span> <span class="n">transpose</span><span class="p">(</span><span class="n">f_lin</span><span class="p">)(</span><span class="n">y_bar</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">f_vjp</span>
</pre></div>
</div>
<p>Since we have the linear computation as a jaxpr, not just a Python callable,
we can implement the transpose transformation as a jaxpr interpreter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vjp_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in</span><span class="p">):</span>
  <span class="n">pvals_in</span> <span class="o">=</span> <span class="p">([</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">known</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">primals_in</span><span class="p">]</span> <span class="o">+</span>
              <span class="p">[</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">vspace</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">primals_in</span><span class="p">])</span>
  <span class="n">primal_pvals_in</span><span class="p">,</span> <span class="n">tangent_pvals_in</span> <span class="o">=</span> <span class="n">split_half</span><span class="p">(</span><span class="n">pvals_in</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">f_jvp</span><span class="p">(</span><span class="o">*</span><span class="n">primals_tangents_in</span><span class="p">):</span>
    <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">split_half</span><span class="p">(</span><span class="n">primals_tangents_in</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">primals_out</span><span class="p">,</span> <span class="o">*</span><span class="n">tangents_out</span><span class="p">]</span>
  <span class="n">jaxpr</span><span class="p">,</span> <span class="n">pvals_out</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">partial_eval_flat</span><span class="p">(</span><span class="n">f_jvp</span><span class="p">,</span> <span class="n">pvals_in</span><span class="p">)</span>  <span class="c1"># linearize</span>
  <span class="n">primal_pvals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_half</span><span class="p">(</span><span class="n">pvals_out</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">primal_pvals</span><span class="p">)</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">primal_pvals</span><span class="p">]</span>
  <span class="n">transpose_inputs</span> <span class="o">=</span> <span class="n">consts</span> <span class="o">+</span> <span class="p">[</span><span class="n">UndefPrimal</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">tangent_pvals_in</span><span class="p">]</span>
  <span class="n">f_vjp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">cts</span><span class="p">:</span> <span class="n">eval_jaxpr_transposed</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">transpose_inputs</span><span class="p">,</span> <span class="n">cts</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">f_vjp</span>

<span class="k">def</span> <span class="nf">vjp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in</span><span class="p">):</span>
  <span class="n">primals_in_flat</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">primals_in</span><span class="p">)</span>
  <span class="n">f</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>
  <span class="n">primals_out_flat</span><span class="p">,</span> <span class="n">f_vjp_flat</span> <span class="o">=</span> <span class="n">vjp_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in_flat</span><span class="p">)</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">primals_out_flat</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">f_vjp</span><span class="p">(</span><span class="o">*</span><span class="n">cotangents_out</span><span class="p">):</span>
    <span class="n">cotangents_out_flat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">cotangents_out</span><span class="p">)</span>
    <span class="n">cotangents_in_flat</span> <span class="o">=</span> <span class="n">f_vjp_flat</span><span class="p">(</span><span class="o">*</span><span class="n">cotangents_out_flat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">in_tree</span><span class="p">,</span> <span class="n">cotangents_in_flat</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">f_vjp</span>

<span class="k">class</span> <span class="nc">UndefPrimal</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>

<span class="n">register_pytree_node</span><span class="p">(</span><span class="n">UndefPrimal</span><span class="p">,</span>
                     <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="p">()),</span>
                     <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">UndefPrimal</span><span class="p">(</span><span class="n">aval</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We use <code class="docutils literal notranslate"><span class="pre">UndefPrimal</span></code> instances to indicate which arguments with respect to
which we want to transpose. These arise because in general, being explicit
about closed-over values, we want to transpose functions of type
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-o</span> <span class="pre">c</span></code> to functions of type <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">c</span> <span class="pre">-o</span> <span class="pre">b</span></code>. Even more generally, the
inputs with respect to which the function is linear could be scattered through
the argument list. So we indicate the linear positions using <code class="docutils literal notranslate"><span class="pre">UndefPrimal</span></code>.
We register <code class="docutils literal notranslate"><span class="pre">UndefPrimal</span></code> as a pytree node because the pytree mechanism gives
a handy way to prune these placeholders out of argument lists.</p>
<p>Next, we can write <code class="docutils literal notranslate"><span class="pre">eval_jaxpr_transposed</span></code>, along with transpose rules for
all primitives which can be linear in at least one argument:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NB: the analogous function in JAX is called &#39;backward_pass&#39;</span>
<span class="k">def</span> <span class="nf">eval_jaxpr_transposed</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">cotangents</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
  <span class="n">primal_env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">ct_env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">def</span> <span class="nf">read_primal</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_env</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">UndefPrimal</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">))</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span>

  <span class="k">def</span> <span class="nf">write_primal</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">UndefPrimal</span><span class="p">:</span>
      <span class="n">primal_env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

  <span class="k">def</span> <span class="nf">read_cotangent</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ct_env</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">write_cotangent</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="ow">and</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">ct_env</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">ct_env</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ct_env</span> <span class="k">else</span> <span class="n">val</span>

  <span class="nb">map</span><span class="p">(</span><span class="n">write_primal</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="nb">map</span><span class="p">(</span><span class="n">write_cotangent</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">,</span> <span class="n">cotangents</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">primals_in</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read_primal</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">cts_in</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read_cotangent</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
    <span class="n">rule</span> <span class="o">=</span> <span class="n">transpose_rules</span><span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">]</span>
    <span class="n">cts_out</span> <span class="o">=</span> <span class="n">rule</span><span class="p">(</span><span class="n">cts_in</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in</span><span class="p">,</span> <span class="o">**</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="nb">map</span><span class="p">(</span><span class="n">write_cotangent</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">cts_out</span><span class="p">)</span>

  <span class="k">return</span> <span class="p">[</span><span class="n">read_cotangent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
          <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span><span class="p">]</span>

<span class="n">transpose_rules</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mul_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="n">z_bar</span><span class="p">,</span> <span class="o">=</span> <span class="n">cts</span>
  <span class="k">assert</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">mul</span><span class="p">(</span><span class="n">z_bar</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="kc">None</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span> <span class="k">else</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z_bar</span><span class="p">)]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">mul_transpose_rule</span>

<span class="k">def</span> <span class="nf">neg_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">ybar</span><span class="p">,</span> <span class="o">=</span> <span class="n">cts</span>
  <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">neg</span><span class="p">(</span><span class="n">ybar</span><span class="p">)]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_transpose_rule</span>

<span class="k">def</span> <span class="nf">add_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="n">z_bar</span><span class="p">,</span> <span class="o">=</span> <span class="n">cts</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">z_bar</span><span class="p">,</span> <span class="n">z_bar</span><span class="p">]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_transpose_rule</span>

<span class="k">def</span> <span class="nf">reduce_sum_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="n">y_bar</span><span class="p">,</span> <span class="o">=</span> <span class="n">cts</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">broadcast</span><span class="p">(</span><span class="n">y_bar</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">)]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_sum_transpose_rule</span>

<span class="k">def</span> <span class="nf">xla_call_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="o">*</span><span class="n">invals</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Unused</span>
  <span class="n">undef_primals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">invals</span><span class="p">]</span>
  <span class="n">transposed_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span> <span class="o">=</span> <span class="n">transpose_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">undef_primals</span><span class="p">))</span>
  <span class="n">residuals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">undef_primals</span><span class="p">,</span> <span class="n">invals</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">new_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">residuals</span><span class="p">,</span> <span class="o">*</span><span class="n">cts</span><span class="p">,</span>
              <span class="n">jaxpr</span><span class="o">=</span><span class="n">transposed_jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_consts</span><span class="p">))</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="k">if</span> <span class="n">undef</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">undef</span> <span class="ow">in</span> <span class="n">undef_primals</span><span class="p">]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_transpose_rule</span>

<span class="nd">@lru_cache</span>
<span class="k">def</span> <span class="nf">transpose_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">undef_primals</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="n">avals_in</span><span class="p">,</span> <span class="n">avals_out</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="n">traceable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">eval_jaxpr_transposed</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">UndefPrimal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">u</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">avals_in</span><span class="p">,</span> <span class="n">undef_primals</span><span class="p">)]</span>
  <span class="n">trans_jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">traceable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">avals_out</span><span class="p">))</span>
  <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">trans_jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">trans_jaxpr</span><span class="p">,</span> <span class="n">consts</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we can linearize and transpose, we can finally write <code class="docutils literal notranslate"><span class="pre">grad</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">gradfun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">):</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">f_vjp</span> <span class="o">=</span> <span class="n">vjp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="p">():</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="n">x_bar</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">f_vjp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">x_bar</span>
  <span class="k">return</span> <span class="n">gradfun</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">,</span> <span class="n">f_vjp</span> <span class="o">=</span> <span class="n">vjp</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="mf">3.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f_vjp</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(np.float64(-0.9899924966004454),) -0.9899924966004454
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="nb">print</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.979984993200891
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>

<span class="nb">print</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.1176619927957034
</pre></div>
</div>
</div>
</div>
<p>Here‚Äôs something of a compositionality stress test:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># from core_test.py fun_with_nested_calls_2</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="nd">@jit</span>
  <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">baz</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
      <span class="n">q</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
      <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">y</span><span class="p">)()</span>
      <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">w</span> <span class="o">+</span> <span class="n">y</span><span class="p">)(</span><span class="n">y</span><span class="p">)</span>
      <span class="n">q</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">jit</span><span class="p">(</span><span class="n">sin</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="p">)(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">q</span>
      <span class="k">return</span> <span class="n">q</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">baz</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">,),</span> <span class="p">(</span><span class="n">y</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">assert_allclose</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

<span class="n">ans1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">ans2</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">ans3</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">5.</span><span class="p">,))</span>
<span class="n">ans4</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">5.</span><span class="p">,))</span>
<span class="n">assert_allclose</span><span class="p">(</span><span class="n">ans1</span><span class="p">,</span> <span class="n">ans2</span><span class="p">,</span> <span class="n">ans3</span><span class="p">,</span> <span class="n">ans4</span><span class="p">)</span>

<span class="n">deriv1</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">deriv2</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">deriv3</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">deriv4</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="n">_</span><span class="p">,</span> <span class="n">deriv5</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="n">assert_allclose</span><span class="p">(</span><span class="n">deriv1</span><span class="p">,</span> <span class="n">deriv2</span><span class="p">,</span> <span class="n">deriv3</span><span class="p">,</span> <span class="n">deriv4</span><span class="p">,</span> <span class="n">deriv5</span><span class="p">)</span>

<span class="n">hess1</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">hess2</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">hess3</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">hess4</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">hess5</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="n">_</span><span class="p">,</span> <span class="n">hess6</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)),</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="n">_</span><span class="p">,</span> <span class="n">hess7</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)),</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="n">assert_allclose</span><span class="p">(</span><span class="n">hess1</span><span class="p">,</span> <span class="n">hess2</span><span class="p">,</span> <span class="n">hess3</span><span class="p">,</span> <span class="n">hess4</span><span class="p">,</span> <span class="n">hess5</span><span class="p">,</span> <span class="n">hess6</span><span class="p">,</span> <span class="n">hess7</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="part-5-the-control-flow-primitives-cond">
<h2>Part 5: the control flow primitives <code class="docutils literal notranslate"><span class="pre">cond</span></code><a class="headerlink" href="#part-5-the-control-flow-primitives-cond" title="Link to this heading">#</a></h2>
<p>Next we‚Äôll add higher-order primitives for staged-out control flow. These
resemble <code class="docutils literal notranslate"><span class="pre">jit</span></code> from Part 3, another higher-order primitive, but differ in that
they are parameterized by multiple callables rather than just one.</p>
<section id="adding-cond">
<h3>Adding <code class="docutils literal notranslate"><span class="pre">cond</span></code><a class="headerlink" href="#adding-cond" title="Link to this heading">#</a></h3>
<p>We introduce a <code class="docutils literal notranslate"><span class="pre">cond</span></code> primitive to represent conditional application of one
function or another inside a jaxpr. We write the type of <code class="docutils literal notranslate"><span class="pre">cond</span></code> as
<code class="docutils literal notranslate"><span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>. In words, <code class="docutils literal notranslate"><span class="pre">cond</span></code> takes a boolean
representing the predicate and two functions of equal types. Depending on the
value of the predicate, it applies one function or the other to its final
argument.</p>
<p>In Python, we represent it as a function which itself takes two functions as
arguments. As with <code class="docutils literal notranslate"><span class="pre">jit</span></code>, the first step is to call <code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code> on its
callable arguments to turn them into jaxprs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">true_fn</span><span class="p">,</span> <span class="n">false_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">):</span>
  <span class="n">avals_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">]</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">true_consts</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">true_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">avals_in</span><span class="p">)</span>
  <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">false_consts</span><span class="p">,</span> <span class="n">out_tree_</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">false_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">avals_in</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out_tree</span> <span class="o">!=</span> <span class="n">out_tree_</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">_join_jaxpr_consts</span><span class="p">(</span>
      <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_consts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_consts</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">true_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">false_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span>
                   <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
<span class="n">cond_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;cond&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_join_jaxpr_consts</span><span class="p">(</span><span class="n">jaxpr1</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="nb">int</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">]:</span>
  <span class="n">jaxpr1_type</span><span class="p">,</span> <span class="n">jaxpr2_type</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr1</span><span class="p">),</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr2</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">jaxpr1_type</span><span class="o">.</span><span class="n">in_types</span><span class="p">[</span><span class="n">n1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">jaxpr2_type</span><span class="o">.</span><span class="n">in_types</span><span class="p">[</span><span class="n">n2</span><span class="p">:]</span>
  <span class="n">consts1</span><span class="p">,</span> <span class="n">rest1</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
  <span class="n">consts2</span><span class="p">,</span> <span class="n">rest2</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr2</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>
  <span class="n">new_jaxpr1</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">consts1</span> <span class="o">+</span> <span class="n">consts2</span> <span class="o">+</span> <span class="n">rest1</span><span class="p">,</span> <span class="n">jaxpr1</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">jaxpr1</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>
  <span class="n">new_jaxpr2</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">consts1</span> <span class="o">+</span> <span class="n">consts2</span> <span class="o">+</span> <span class="n">rest2</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr1</span><span class="p">,</span> <span class="n">new_jaxpr2</span>

<span class="k">def</span> <span class="nf">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">bind</span><span class="p">(</span><span class="n">cond_p</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">false_jaxpr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We require <code class="docutils literal notranslate"><span class="pre">true_jaxpr</span></code> and <code class="docutils literal notranslate"><span class="pre">false_jaxpr</span></code> to have the same type, but because
they might close over different constants (and because jaxprs can only
represent closed terms, i.e. can‚Äôt have free variables and are instead
closure-converted) we need to use the helper <code class="docutils literal notranslate"><span class="pre">_join_jaxpr_consts</span></code> to make
consistent the input binder lists of the two jaxprs. (To be more economical we
could try to identify pairs of constants with the same shapes, but instead we
just concatenate the lists of constants.)</p>
<p>Next we can turn to adding interpreter rules for <code class="docutils literal notranslate"><span class="pre">cond</span></code>. Its evaluation rule
is simple:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_impl</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">pred</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">operands</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">operands</span><span class="p">)</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_impl</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
<p>For its JVP and vmap rules, we only need to call the same <code class="docutils literal notranslate"><span class="pre">jvp_jaxpr</span></code> and
<code class="docutils literal notranslate"><span class="pre">vmap_jaxpr</span></code> utilities we created for <code class="docutils literal notranslate"><span class="pre">jit</span></code>, followed by another pass of
<code class="docutils literal notranslate"><span class="pre">_join_jaxpr_consts</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">primals</span> <span class="o">=</span> <span class="n">primals</span>
  <span class="n">_</span>   <span class="p">,</span> <span class="o">*</span><span class="n">tangents</span> <span class="o">=</span> <span class="n">tangents</span>
  <span class="n">true_jaxpr</span> <span class="p">,</span> <span class="n">true_consts</span>  <span class="o">=</span> <span class="n">jvp_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span>
  <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">false_consts</span> <span class="o">=</span> <span class="n">jvp_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">_join_jaxpr_consts</span><span class="p">(</span>
      <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_consts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_consts</span><span class="p">))</span>
  <span class="k">assert</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span> <span class="o">==</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">true_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">false_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">primals</span><span class="p">,</span> <span class="o">*</span><span class="n">tangents</span><span class="p">,</span>
                   <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">split_half</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_jvp_rule</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">,</span> <span class="n">out_tan</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out_tan</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_vmap_rule</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="n">pred</span>    <span class="p">,</span> <span class="o">*</span><span class="n">vals_in</span> <span class="o">=</span> <span class="n">vals_in</span>
  <span class="n">pred_dim</span><span class="p">,</span> <span class="o">*</span><span class="n">dims_in</span> <span class="o">=</span> <span class="n">dims_in</span>
  <span class="k">if</span> <span class="n">pred_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">not_mapped</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># TODO</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">true_consts</span> <span class="o">=</span> <span class="n">vmap_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_in</span><span class="p">))</span>
  <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">false_consts</span> <span class="o">=</span> <span class="n">vmap_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_in</span><span class="p">))</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">_join_jaxpr_consts</span><span class="p">(</span>
      <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_consts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_consts</span><span class="p">))</span>
  <span class="k">assert</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span> <span class="o">==</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">true_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">false_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">vals_in</span><span class="p">,</span>
                   <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">outs</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_vmap_rule</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))(</span><span class="n">xs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2. 3. 4.]
</pre></div>
</div>
</div>
</div>
<p>Notice that we‚Äôre not currently supporting the case where the predicate value
itself is batched. In mainline JAX, we handle this case by transforming the
conditional to a <a class="reference external" href="https://docs.jax.dev/en/latest/_autosummary/jax.lax.select.html">select primitive</a>.
That transformation is semantically correct so long as <code class="docutils literal notranslate"><span class="pre">true_fun</span></code> and
<code class="docutils literal notranslate"><span class="pre">false_fun</span></code> do not involve any side-effecting primitives.</p>
<p>Another thing not represented here, but present in the mainline JAX, is that
applying transformations to two jaxprs of equal type might result in jaxprs of
different types. For example, applying the mainline JAX version of
<code class="docutils literal notranslate"><span class="pre">vmap_jaxpr</span></code> to the identity-function jaxpr</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">float32</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>would result in a jaxpr with a batched output, of type
<code class="docutils literal notranslate"><span class="pre">[float32[10]]</span> <span class="pre">-&gt;</span> <span class="pre">[float32[10]]</span></code> if the batch size were 10, while applying it
to the zero-function jaxpr</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">float32</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="mf">0.</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>would result in a jaxpr with an unbatched output, of type
<code class="docutils literal notranslate"><span class="pre">[float32[10]]</span> <span class="pre">-&gt;</span> <span class="pre">[float32[]]</span></code>. This is an optimization, aimed at not batching
values unnecessarily. But it means that in <code class="docutils literal notranslate"><span class="pre">cond</span></code> we‚Äôd need an extra step of
joining the two transformed jaxprs to have consistent output types. We don‚Äôt
need this step here because we chose <code class="docutils literal notranslate"><span class="pre">vmap_jaxpr</span></code> always to batch all outputs
over the leading axis.</p>
<p>Next we can turn to abstract evaluation and XLA lowering rules:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_abstract_eval</span><span class="p">(</span><span class="n">pred_type</span><span class="p">,</span> <span class="o">*</span><span class="n">in_types</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">pred_type</span> <span class="o">!=</span> <span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="n">jaxpr_type</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">jaxpr_type</span> <span class="o">!=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span> <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr_type</span><span class="o">.</span><span class="n">in_types</span><span class="p">,</span> <span class="n">in_types</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">return</span> <span class="n">jaxpr_type</span><span class="o">.</span><span class="n">out_types</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_abstract_eval</span>

<span class="k">def</span> <span class="nf">cond_translation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">in_avals</span>  <span class="c1"># Unused</span>
  <span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">in_vals</span> <span class="o">=</span> <span class="n">in_vals</span>

  <span class="n">op</span> <span class="o">=</span> <span class="n">hlo</span><span class="o">.</span><span class="n">IfOp</span><span class="p">([</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">out_avals</span><span class="p">],</span> <span class="n">pred</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">InsertionPoint</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">true_branch</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">()):</span>
    <span class="n">hlo</span><span class="o">.</span><span class="n">return_</span><span class="p">(</span><span class="n">jaxpr_subcomp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">))</span>
  <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">InsertionPoint</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">false_branch</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">()):</span>
    <span class="n">hlo</span><span class="o">.</span><span class="n">return_</span><span class="p">(</span><span class="n">jaxpr_subcomp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">results</span>

<span class="n">hlo_translations</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_translation</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">2</span><span class="p">))()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>Finally, to support reverse-mode automatic differentiation, we need partial
evaluation and transposition rules. For partial evaluation, we need to
introduce another jaxpr-munging utility, <code class="docutils literal notranslate"><span class="pre">_join_jaxpr_res</span></code>, to handle the fact
that applying partial evaluation to <code class="docutils literal notranslate"><span class="pre">true_fun</span></code> and <code class="docutils literal notranslate"><span class="pre">false_fun</span></code> will in general
result in distinct residuals. We use <code class="docutils literal notranslate"><span class="pre">_join_jaxpr_res</span></code> to make the output
types of the transformed jaxprs consistent (while <code class="docutils literal notranslate"><span class="pre">_join_jaxpr_consts</span></code> dealt
with input types).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_partial_eval</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="n">pred_tracer</span><span class="p">,</span> <span class="o">*</span><span class="n">tracers</span> <span class="o">=</span> <span class="n">tracers</span>
  <span class="k">assert</span> <span class="n">pred_tracer</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span>
  <span class="n">pred</span> <span class="o">=</span> <span class="n">pred_tracer</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span>
  <span class="n">in_uks</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>

  <span class="o">*</span><span class="n">jaxprs</span><span class="p">,</span> <span class="n">out_uks</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="n">_cond_partial_eval</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">in_uks</span><span class="p">)</span>
  <span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr1</span><span class="p">,</span> <span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">f_jaxpr2</span> <span class="o">=</span> <span class="n">jaxprs</span>

  <span class="n">known_tracers</span><span class="p">,</span> <span class="n">unknown_tracers</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">in_uks</span><span class="p">,</span> <span class="n">tracers</span><span class="p">)</span>
  <span class="n">known_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">known_tracers</span><span class="p">]</span>
  <span class="n">outs1_res</span> <span class="o">=</span> <span class="n">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">known_vals</span><span class="p">,</span>
                        <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">f_jaxpr1</span><span class="p">)</span>
  <span class="n">outs1</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">outs1_res</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs1_res</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_res</span><span class="p">)</span>
  <span class="n">pred_tracer_</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">(</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">pred_tracer</span><span class="p">))</span>
  <span class="n">res_tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">(</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
  <span class="n">outs2</span> <span class="o">=</span> <span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">t_jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">]</span>
  <span class="n">eqn</span> <span class="o">=</span> <span class="n">JaxprEqnRecipe</span><span class="p">(</span><span class="n">cond_p</span><span class="p">,</span> <span class="p">[</span><span class="n">pred_tracer_</span><span class="p">,</span> <span class="o">*</span><span class="n">res_tracers</span><span class="p">,</span> <span class="o">*</span><span class="n">unknown_tracers</span><span class="p">],</span>
                       <span class="nb">dict</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="o">=</span><span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">f_jaxpr2</span><span class="p">),</span>
                       <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">t_jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">],</span> <span class="nb">map</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">outs2</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">outs2</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="n">eqn</span>
  <span class="k">return</span> <span class="n">merge_lists</span><span class="p">(</span><span class="n">out_uks</span><span class="p">,</span> <span class="n">outs1</span><span class="p">,</span> <span class="n">outs2</span><span class="p">)</span>
<span class="n">partial_eval_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_partial_eval</span>

<span class="k">def</span> <span class="nf">_cond_partial_eval</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">in_uks</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">t_out_uks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span> <span class="p">,</span> <span class="n">in_uks</span><span class="p">)</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">f_out_uks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">in_uks</span><span class="p">)</span>
  <span class="n">out_uks</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">t_out_uks</span><span class="p">,</span> <span class="n">f_out_uks</span><span class="p">)</span>

  <span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">t_nres</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span> <span class="p">,</span> <span class="n">in_uks</span><span class="p">,</span> <span class="n">out_uks</span><span class="p">)</span>
  <span class="n">f_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">f_nres</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">in_uks</span><span class="p">,</span> <span class="n">out_uks</span><span class="p">)</span>

  <span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr1</span> <span class="o">=</span> <span class="n">_join_jaxpr_res</span><span class="p">(</span><span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr1</span><span class="p">,</span> <span class="n">t_nres</span><span class="p">,</span> <span class="n">f_nres</span><span class="p">)</span>
  <span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">f_jaxpr2</span> <span class="o">=</span> <span class="n">_join_jaxpr_consts</span><span class="p">(</span><span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">f_jaxpr2</span><span class="p">,</span> <span class="n">t_nres</span><span class="p">,</span> <span class="n">f_nres</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">t_jaxpr1</span><span class="p">)</span> <span class="o">==</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">f_jaxpr1</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">t_jaxpr2</span><span class="p">)</span> <span class="o">==</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">f_jaxpr2</span><span class="p">)</span>
  <span class="n">num_res</span> <span class="o">=</span> <span class="n">t_nres</span> <span class="o">+</span> <span class="n">f_nres</span>

  <span class="k">return</span> <span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr1</span><span class="p">,</span> <span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">f_jaxpr2</span><span class="p">,</span> <span class="n">out_uks</span><span class="p">,</span> <span class="n">num_res</span>

<span class="k">def</span> <span class="nf">_join_jaxpr_res</span><span class="p">(</span><span class="n">jaxpr1</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="nb">int</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">]:</span>
  <span class="n">jaxpr1_type</span><span class="p">,</span> <span class="n">jaxpr2_type</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr1</span><span class="p">),</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr2</span><span class="p">)</span>
  <span class="n">out_types1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr1_type</span><span class="o">.</span><span class="n">out_types</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span> <span class="o">-</span> <span class="n">n1</span><span class="p">)</span>
  <span class="n">out_types2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr2_type</span><span class="o">.</span><span class="n">out_types</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span> <span class="o">-</span> <span class="n">n2</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">out_types1</span> <span class="o">==</span> <span class="n">out_types2</span>
  <span class="n">outs1</span><span class="p">,</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">outs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span> <span class="o">-</span> <span class="n">n1</span><span class="p">)</span>
  <span class="n">outs2</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span> <span class="o">-</span> <span class="n">n2</span><span class="p">)</span>
  <span class="n">zeros_like1</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">res1</span><span class="p">]</span>
  <span class="n">zeros_like2</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">res2</span><span class="p">]</span>
  <span class="n">new_jaxpr1</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">jaxpr1</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">outs1</span> <span class="o">+</span> <span class="n">res1</span> <span class="o">+</span> <span class="n">zeros_like2</span><span class="p">)</span>
  <span class="n">new_jaxpr2</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">jaxpr2</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">outs2</span> <span class="o">+</span> <span class="n">zeros_like1</span> <span class="o">+</span> <span class="n">res2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr1</span><span class="p">,</span> <span class="n">new_jaxpr2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.</span><span class="p">),</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">f_lin</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.14
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_peval_eqn</span><span class="p">(</span><span class="n">unks_in</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">,</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">JaxprEqn</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Atom</span><span class="p">]]:</span>
  <span class="n">pred_unk</span><span class="p">,</span> <span class="o">*</span><span class="n">unks_in</span> <span class="o">=</span> <span class="n">unks_in</span>
  <span class="k">assert</span> <span class="ow">not</span> <span class="n">pred_unk</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;true_jaxpr&#39;</span><span class="p">],</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;false_jaxpr&#39;</span><span class="p">]</span>
  <span class="o">*</span><span class="n">jaxprs</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="n">_cond_partial_eval</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">unks_in</span><span class="p">)</span>
  <span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr1</span><span class="p">,</span> <span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">f_jaxpr2</span> <span class="o">=</span> <span class="n">jaxprs</span>
  <span class="n">ins1</span><span class="p">,</span> <span class="n">ins2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
  <span class="n">outs1</span><span class="p">,</span> <span class="n">outs2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_out</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
  <span class="n">residuals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">t_jaxpr2</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">num_res</span><span class="p">)</span>
  <span class="n">eqn1</span> <span class="o">=</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">cond_p</span><span class="p">,</span> <span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">ins1</span><span class="p">],</span>
                  <span class="nb">dict</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="o">=</span><span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">f_jaxpr1</span><span class="p">),</span>
                  <span class="n">outs1</span> <span class="o">+</span> <span class="n">residuals</span><span class="p">)</span>
  <span class="n">eqn2</span> <span class="o">=</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">cond_p</span><span class="p">,</span> <span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">residuals</span><span class="p">,</span> <span class="o">*</span><span class="n">ins2</span><span class="p">],</span>
                  <span class="nb">dict</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="o">=</span><span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">f_jaxpr2</span><span class="p">),</span>
                  <span class="n">outs2</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">residuals</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">residuals</span>
  <span class="k">return</span> <span class="n">eqn1</span><span class="p">,</span> <span class="n">eqn2</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">res</span>
<span class="n">partial_eval_jaxpr_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_peval_eqn</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.</span><span class="p">)),</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">f_lin</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.14
</pre></div>
</div>
</div>
</div>
<p>Transposition is a fairly straightforward application of <code class="docutils literal notranslate"><span class="pre">transpose_jaxpr</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">invals</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="n">undef_primals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">invals</span><span class="p">)</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">true_consts</span> <span class="o">=</span> <span class="n">transpose_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">undef_primals</span><span class="p">)</span>
  <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">false_consts</span> <span class="o">=</span> <span class="n">transpose_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">undef_primals</span><span class="p">)</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">_join_jaxpr_consts</span><span class="p">(</span>
      <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_consts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_consts</span><span class="p">))</span>
  <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">invals</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">UndefPrimal</span><span class="p">]</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">true_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">false_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">cts</span><span class="p">,</span>
                   <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">invals</span><span class="p">]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_transpose_rule</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.</span><span class="p">))(</span><span class="mf">1.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.0
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pprint_cond</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;true_jaxpr&#39;</span><span class="p">],</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;false_jaxpr&#39;</span><span class="p">]</span>
  <span class="n">new_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;jaxpr&#39;</span><span class="p">)}</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">var_str</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">))</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">pp_params</span><span class="p">(</span><span class="n">new_params</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
         <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Var</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">vcat</span><span class="p">([</span><span class="n">lhs</span> <span class="o">&gt;&gt;</span> <span class="n">pp</span><span class="p">(</span><span class="s1">&#39; = &#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rhs</span><span class="p">,</span>
               <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
               <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">)</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">pp_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pprint_cond</span>
</pre></div>
</div>
</div>
</details>
</div>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="investigating_a_regression.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Investigating a regression</p>
      </div>
    </a>
    <a class="right-next"
       href="autodidax2_part1.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Autodidax2, part 1: JAX from scratch, again</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-1-transformations-as-interpreters-standard-evaluation-jvp-and-vmap">Part 1: Transformations as interpreters: standard evaluation, <code class="docutils literal notranslate"><span class="pre">jvp</span></code>, and <code class="docutils literal notranslate"><span class="pre">vmap</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#jax-core-machinery">JAX core machinery</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#evaluation-interpreter">Evaluation interpreter</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#forward-mode-autodiff-with-jvp">Forward-mode autodiff with <code class="docutils literal notranslate"><span class="pre">jvp</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pytrees-and-flattening-user-functions-inputs-and-outputs">Pytrees and flattening user functions‚Äô inputs and outputs</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vectorized-batching-with-vmap">Vectorized batching with <code class="docutils literal notranslate"><span class="pre">vmap</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-2-jaxprs">Part 2: Jaxprs</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#jaxpr-data-structures">Jaxpr data structures</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#building-jaxprs-with-tracing">Building jaxprs with tracing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-3-jit-simplified">Part 3: <code class="docutils literal notranslate"><span class="pre">jit</span></code>, simplified</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#on-the-fly-final-style-and-staged-initial-style-processing">On-the-fly (‚Äúfinal style‚Äù) and staged (‚Äúinitial style‚Äù) processing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-4-linearize-and-vjp-and-grad">Part 4: <code class="docutils literal notranslate"><span class="pre">linearize</span></code> and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> (and <code class="docutils literal notranslate"><span class="pre">grad</span></code>!)</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linearize"><code class="docutils literal notranslate"><span class="pre">linearize</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vjp-and-grad"><code class="docutils literal notranslate"><span class="pre">vjp</span></code> and <code class="docutils literal notranslate"><span class="pre">grad</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-5-the-control-flow-primitives-cond">Part 5: the control flow primitives <code class="docutils literal notranslate"><span class="pre">cond</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adding-cond">Adding <code class="docutils literal notranslate"><span class="pre">cond</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By The JAX authors
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      ¬© Copyright 2024, The JAX Authors.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=5b4479735964841361fd"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>